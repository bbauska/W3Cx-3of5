<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-1-1">3.1.1 HTML5 Graphics - Introduction</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-1">3.2.1 About JavaScript and HTML5</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 115. javascript logo (136) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image115.webp"
  loading="lazy"
  style="width:10%"
  title="JavaScript logo"
  alt="JavaScript logo." />

<p>HTML5 is composed of new elements, but it also comes with many
JavaScript APIs for controlling video and sound, drawing and animating
things in the new &lt;canvas&gt; element, for offline applications,
persistence, geolocation, orientation, etc.</p>

<p>So yes, during this course, in particular in Modules 3 and 4, you
will have to do a bit of JavaScript. <b>But, DON’T PANIC!</b></p>

<p>Here we provide a basic introduction to JavaScript. If you want to
learn more, many resources are available on the Web; this document is
simply here to give you a head start. Remember that one great thing
about these MOOCs courses is that everybody can help each other.
Some students are very good in JavaScript and are usually very happy to
help others when they encounter difficulties.</p>

<p><b>You will learn a lot by looking at examples, tweaking them, cloning
and modifying them, etc.</b> Many previous students who were real
JavaScript beginners managed to do [all] the assignments (drawing and
animating a monster with keyboard/mouse interaction)! And they did
this by just studying the provided examples.</p>

<h4>External resources</h4>

<ul>
  <li>The <a href="https://www.edx.org/course/javascript-introduction" target="_blank" 
    rel="noopener noreferrer">JavaScript Introduction</a> course on W3Cx!</li>
  <li>Mozilla Developer Network <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" 
    target="_blank" rel="noopener noreferrer">has a JavaScript guide</a></li>
</ul>

<h4>What do you need? How to debug? How to catch errors?</h4>

<p>We will not look at the JavaScript syntax here, but more at "JavaScript in 
the browser", how it works, how to start writing code, etc.</p>

<p>First of all, you need to find a way to debug your code and see errors. If 
your work does not produce any results, you must know why! For that you will 
use <b>the dev. tools of your browser</b>. Press <i>F12</i> in Windows or 
<i>cmd-alt-i</i> in Mac to open the dev. tools, then go to the console tab: 
this is where errors will be displayed, or messages of your own (use the 
console.log(string) JavaScript function in the JavaScript code embedded in your 
html page). In the console, you will be able to type any JavaScript command.</p>

<p>Let’s look at <a href="https://jsbin.com/visariz/1/edit?html,output" 
target="_blank" rel="noopener noreferrer">this example on JS Bin</a>:</p>

<pre>&lt;div&gt;
  &lt;table&gt;
    &lt;colgroup&gt;
      &lt;col style="width: 1%" /&gt;
      &lt;col style="width: 98%" /&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
    &lt;tr class="header"&gt;
      &lt;th&gt;#&lt;/th&gt;
      &lt;th&gt;HTML code&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;&lt;!DOCTYPE html&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/html.html" target="_blank" 
      rel="noopener noreferrer"&gt;&lt;b&gt;html lang=“en”&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/head.html" target="_blank" 
      rel="noopener noreferrer"&gt;&lt;b&gt;head&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;4&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/meta.html" target="_blank" 
      rel="noopener noreferrer"&gt;&lt;b&gt;meta&lt;/b&gt;&lt;/a&gt; charset=utf-8 /&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/title.html" 
      target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;title&lt;/b&gt;&lt;/a&gt;&gt;
      Web Audio API&lt;/&lt;a href="https://december.com/html/4/element/title.html" 
      target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;title&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/script.html" 
      target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;console.log("Some JavaScript code has been executed");&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;8&lt;/td&gt;
    &lt;td&gt;&lt;/&lt;a href="https://december.com/html/4/element/script.html" 
      target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;9&lt;/td&gt;
    &lt;td&gt;&lt;/&lt;a href="https://december.com/html/4/element/head.html" target="_blank" 
      rel="noopener noreferrer"&gt;&lt;b&gt;head&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;10&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/body.html" target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;body&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;11&lt;/td&gt;
    &lt;td&gt;&lt;&lt;a href="https://december.com/html/4/element/h1.html" target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;h1&lt;/b&gt;&lt;/a&gt;&gt;JavaScript debugging using the dev tool console&lt;/&lt;a href="https://december.com/html/4/element/h1.html" target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;h1&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;12&lt;/td&gt;
    &lt;td&gt;&lt;/&lt;a href="https://december.com/html/4/element/body.html" target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;body&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;13&lt;/td&gt;
    &lt;td&gt;&lt;/&lt;a href="https://december.com/html/4/element/html.html" 
      target="_blank" rel="noopener noreferrer"&gt;&lt;b&gt;html&lt;/b&gt;&lt;/a&gt;&gt;&lt;/td&gt;
  &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/div&gt;</pre>

<p>The simplest way to add JavaScript code in an HTML page, is by using
the &lt;script&gt;…&lt;/script&gt; element.</p>

<p><b>The code in this example is executed sequentially when the page is
loaded</b>: the JavaScript code is executed before the browser could see
the rest of the page (as the &lt;script&gt;&lt;/script&gt; is located
before the &lt;body&gt;).</p>

<p>The H1 element, for example, does not exist in the Document Object
Model, and has not yet been displayed when the JavaScript code is
executed. If we move the &lt;script&gt;&lt;/script&gt; at the end of the
document, then the H1 would have been built before the JavaScript code
is executed.</p>

<p>The only line of code we have is console.log(“Some JavaScript code
has been executed”);</p>

<p>This means “display in the JavaScript console the message…”. If we open
the console tab provided by jsbin.com in a dedicated tab (that redirects
all console.log() messages), and re-execute the page (just type a space
at the end of a line, this will re-render the page and display the
message in the console), we see the message in the console tab, as well
as in the dev. tools console. This is illustrated by the image below:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~ 116. javascript debugging console view (138) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image116.webp"
  loading="lazy"
  style="width:40%"
  title="JavaScript debugging using the dev tool console"
  alt="JavaScript debugging using the dev tool console." />

<p>It is also possible to use the “real dev. tool console”, and for this
I recommend running the application in a single window, not in the JS
Bin editor. Press the black arrow on the top right of the output window
- this will render the page as a standalone Web page, then
press <i>F12</i>. You should see:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~ 117. view of the javascript debug devtool console (139) ~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  loading="lazy"
  src="./images/image117.webp"
  style="width:40%"
  title="View of the JavaScript Debug Devtool console"
  alt="View of the JavaScript Debug Devtool console." />

<p>Ok, now, let’s make an error:
change console.log() into conso<b>lll</b>e.log(). Let’s see what
happens:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 118. view of the javascript console (139) ~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image118.webp"
  loading="lazy"
  style="width:40%"
  title="View of the JavaScript console"
  alt="View of the JavaScript console." />

<p>And if we run it standalone and use the dev. tool console:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 119. dev tool for error inspection (139) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image119.webp"
  loading="lazy"
  style="width:40%"
  title="Dev tool for error inspection"
  alt="Dev tool for error inspection." />

<p>And if we click on the line number in the right, the dev. tool shows
the source code centered on the line that caused the error:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~ 120. view of the javascript console (140) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image120.webp"
  loading="lazy"
  style="width:40%"
  title="View of the JavaScript console. We can see an extract of the source code with 
  different tools for watching variable values over execution etc"
  alt="View of the JavaScript console. We can see an extract of the source code with 
  different tools for watching variable values over execution etc." />

<p>Without such tools, debugging JavaScript code is impossible. So you
need to look at some basic tutorials on how to use the dev. tools of
your browsers, since they differ from one another in the way they work
- although the principles remain the same.</p>

<h4>About the asynchronous nature of JavaScript</h4>

<p>Some of you may not be used to “asynchronous programming”, “callbacks” etc. We 
recommend to read <a href="https://en.wikipedia.org/wiki/Callback_%28computer_programming%29" 
target="_blank" rel="noopener noreferrer">this article on WikiPedia</a> and 
<a href="https://stackoverflow.com/questions/8736378/what-is-a-callback-in-java" 
target="_blank" rel="noopener noreferrer">this thread on StackOverflow</a>.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-2">3.2.2 The &lt;canvas&gt; Element</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 121. canvas element logo (139) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image121.webp"
  loading="lazy"
  style="width:10%"
  title="Canvas element logo"
  alt="Canvas element logo." />

<p>The &lt;canvas&gt; tag was introduced into the HTML specification
around 2010 as a “Flash killer.” At the time, popular video games used
this proprietary technology and only a few browsers supported it. The
HTML canvas allows drawing and animation at 60 frames per second, in 2D
or 3D.</p>
<p><b>The canvas has been designed for pixel-based graphics</b>, while
SVG (Scalable Vector Graphics, another W3C standard) is for vector-based
graphics.</p>
<p>Indeed, the canvas JavaScript drawing API supports different kind of
shapes: lines, rectangles, ellipses, arcs, curves, text, images. Some
drawing styles need to be specified that will affect the way shapes are
drawn (color, drawing width, shadows, etc.). An alpha channel for
drawing in transparent mode is also supported, as well as many advanced
drawing modes and global filters (blur, etc.).</p>
<p>The canvas is also used to do animations at 60 frames per second (useful
for games), to display videos with special effects, to display a webcam
stream, and so on.</p>

<h4>Examples</h4>

<p>Here are some fun examples that show the interest of the HTML5
canvas.</p>

<h4>Example #1</h4>

<p><a href="https://www.ravalmatic.com/portfolio/footchinko/" target="_blank" rel="noopener noreferrer">Foot
Chinko</a> is one popular free HTML5 games:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~ 122. foot chinko one of the best html5 2D game of 2015 (141) ~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image122.webp"
  loading="lazy"
  style="width:40%"
  title="Foot chinko one of the best html5 2D game of 2015"
  alt="Foot chinko one of the best html5 2D game of 2015." />

<h4>Example #2</h4>

<p>Lots of data visualization tools and JavaScript libraries use the HTML5 canvas element for <a
href="http://www.creativebloq.com/design-tools/data-visualization-712402" target="_blank" 
rel="noopener noreferrer">Data visualization</a>:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 123. html5 data visualization (142) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image123.webp"
  loading="lazy"
  style="width:40%"
  title="html5 data visualization, bar graphs"
  alt="html5 data visualization, bar graphs." />

<h4>Example #3</h4>

<p>A version of the <a href="https://intersoft.itch.io/galaxian" target="_blank" 
rel="noopener noreferrer">arcade game Galaxian</a>, that runs at 60 frames per 
second in an HTML5 canvas element:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~ 124. A version of the game Galaxian that runs at 60 frames/s in a canvas. (142) ~~~~~~-->
<img class="displayed"
  src="./images/image124.webp"
  loading="lazy"
  style="width:40%"
  title="A version of the game Galaxian that runs at 60 frames/s in a canvas"
  alt="A version of the game Galaxian that runs at 60 frames/s in a canvas." />

<p>Performance is  good and animation is generally very smooth, since most Web browsers 
(mobile and desktop) support hardware acceleration.</p>
<p><b>Note</b>: 3D drawing using the WebGL API is also possible in a &lt;canvas&gt;, 
but will not be covered in this course. For the most curious among you, please have 
a look at the two popular libraries for doing 3D drawing/animation in a &lt;canvas&gt;: 
<a href="https://www.babylonjs.com/" target="_blank" rel="noopener noreferrer">BabylonJS</a> 
and <a href="https://threejs.org/" target="_blank" rel="noopener noreferrer">ThreeJS</a>.</p>

<h4>External resources</h4>

<ul>
  <li>Comprehensive <a href="https://www.html5canvastutorials.com/" target="_blank" 
    rel="noopener noreferrer">HTML5 canvas tutorials</a></li>
  <li>An <a href="https://joshondesign.com/p/books/canvasdeepdive/title.html" 
    target="_blank" rel="noopener noreferrer">HTML Canvas Deep Dive</a></li>
  <li>MDN’s Web docs: <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" 
    target="_blank" rel="noopener noreferrer">&lt;canvas&gt;: The Graphics Canvas element</a></li>
  <li>The &lt;canvas&gt; element is well supported by browsers:<br>
  <ul>
    <li>CanIUse: <a href="https://caniuse.com/canvas" target="_blank" rel="noopener noreferrer">
      browser support table</a></li>
    <li>MDN’s <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#Browser_compatibility" 
      target="_blank" rel="noopener noreferrer">compatibility table of &lt;canvas&gt;</a></li>
  </ul>
  </li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-3">3.2.3 Canvas and Accessibility</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The dynamic nature of the &lt;canvas&gt; element has made it difficult to use in 
applications that need to be accessible to people with disabilities. To be accessible, 
it must meet the following principles:</p>

<ul>
  <li>Providing alternative content for what is drawn on the &lt;canvas&gt;,</li>
  <li>Exposing the location of shapes, paths, images drawn on the &lt;canvas&gt; to assistive technologies,</li>
  <li>Visually indicating whether or not a shape in the canvas had keyboard focus.</li>
</ul>

<h4>Read more on this topic:</h4>

<ul>
  <li>An article on <a href="https://www.creativebloq.com/web-design/canvas-element-accessibility-41514740" 
    target="_blank" rel="noopener noreferrer">What the canvas element means for accessibility</a></li>
  <li>From the W3C wiki: <a href="https://www.w3.org/html/wg/wiki/AddedElementCanvas" target="_blank" 
    rel="noopener noreferrer">Canvas Element Accessibility Issues</a></li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-4">3.2.4 HTML Canvas Cheatsheet</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>We recommend these 2 quick references (or <a
href="https://en.wikipedia.org/wiki/Cheat_sheet" target="_blank" rel="noopener noreferrer">cheatsheets</a>) below.
Do not hesitate to keep your favorite one open in a separate browser
ta</p>

<ol type="1">
  <li>As a <a href="https://courses.edx.org/assets/courseware/v1/4b7360cab7f3bf439c26782ec47cf7a8/asset-v1:W3Cx+HTML5.1x+2T2020+type@asset+block/Infopgraphic-CanvasCheatSheet-Final2.pdf" 
    target="_blank" rel="noopener noreferrer">PDF file</a>, this canvas cheatsheet:</li>
</ol>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~ 125. snapshot of a canvas cheatsheet from skilled.com (143) ~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image125.webp"
  loading="lazy"
  style="width:40%;"
  title="Snapshot of an Canvas cheatsheet from skilled.com"
  alt="Snapshot of an Canvas cheatsheet from skilled.com." />

<ol start="2" type="1">
  <li>Another resource, as an <a href="https://simon.html5.org/dump/html5-canvas-cheat-sheet.html" 
    target="_blank" rel="noopener noreferrer">HTML file</a>:</li>
</ol>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~ 126. snapshot of a html5 canvas cheatsheet api (144) ~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image126.webp"
  loading="lazy"
  style="width:40%;"
  title="Snapshot of HTML5 Canvas cheatsheet API"
  alt="Snapshot of HTML5 Canvas cheatsheet API." />

<!--  style="width:1388px;height;1087px;" -->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-5">3.2.5 Coordinate System</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The coordinate system used for drawing in canvases is similar to the one used by many 
drawing APIs like Java2D: the (0 , 0) is in the top left corner while the X axis is going 
to the right and the Y axis to the bottom, as  shown in the following picture:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 127. coordinate system (144) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image127.webp"
  loading="lazy"
  style="width:40%"
  title="Coordinate system"
  alt="Coordinate system." />

<ul>
  <li><b>X</b> axis is horizontal, directed to the right,</li>
  <li><b>Y</b> axis is vertical, directed downwards.</li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-6">3.2.6 Drawing Rectangles in a Canvas</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>Small errata about what I said in the above video: “So let’s get the canvas using the 
DOM API method document.getElementById() or better, use document.querySelector() that is 
a more recent method from the DOM API”..</p>

<p>The part is bold is not correct: querySelector, technically, comes from 
<a href="https://www.w3.org/TR/selectors-api/" target="_blank" rel="noopener noreferrer">
Selectors API</a>. Just in case some people would like to check the specification.</p>

<h4>Detailed explanation of the example shown in the above video</h4>

<p>Here are the different steps, in a little more detail, of the example demonstrated in 
the above video:</p>

<h4>1 - Add the &lt;canvas&gt; element into an HTML page</h4>

<pre>&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;225&quot;&gt;
  Fallback content that will be displayed in case the web browser
  does not support the canvas tag or in case scripting
  is disabled.
&lt;/canvas&gt;</pre>

<p>Place code similar to the above somewhere in an HTML page. This example defines an 
area of 300 by 225 pixels on which content can be rendered with JavaScript.</p>

<p>Normally you should see nothing as a result; by default canvases are “transparent”. 
<b>Make it visible using CSS!</b> For example, you can add a border to the canvas (or 
change the background color, or put an image in the background).</p>

<h4>The three lines of CSS will create a border around the canvas with id=“myCanvas”, 
of 1 pixel width, in black:</h4>

<pre>&lt;style&gt;
  #myCanvas {
    border:1px solid black;
  }
&lt;/style&gt;</pre>

<h4>2 - Select the &lt;canvas&gt; element for use from JavaScript</h4>

<p>We can have more than one &lt;canvas&gt; in a single page, and canvases will be 
manipulated with JavaScript like other elements in the DOM.</p>

<h4>For example with:</h4>

<pre>var canvas = document.getElementById(&quot;myCanvas&quot;);</pre>

<h4>… or with the querySelector() method introduced by HTML5, that use the CSS selector 
syntax for selecting elements:</h4>

<pre>var canvas = document.querySelector(&quot;#myCanvas&quot;);</pre>

<h4>3 - Get a “2D context” associated with the canvas</h4>

<p>This step is useful for drawing and setting drawing properties (color, etc.)</p>

<p>Once we have a pointer to the &lt;canvas&gt;, we can get a “context”. This particular 
object is the core of the canvas JavaScript API. It provides methods for drawing, like 
fillRect(x, y, width, height) for example, that draws a filled rectangle, and properties 
for setting the color, shadows, gradients, etc.</p>

<h4>Let’s first get the context (do this only once):</h4>

<pre>var ctx=canvas.getContext(&#39;2d&#39;);</pre>

<h4>… then, set the color for drawing filled shapes:</h4>

<pre>ctx.fillStyle=&#39;red&#39;;</pre>

<h4>… and draw a filled rectangle:</h4>

<pre>ctx.fillRect(0,0,80,100);</pre>

<h4>Complete example that draws a filled rectangle in red:</h4>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;style&gt;
    #myCanvas {
    border: 1px solid black;
    }
  &lt;/style&gt;
&lt;title&gt;Canvas&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;script&gt;
    var canvas, ctx;
    function init() {
    // This function is called after the page is loaded
    // 1 - Get the canvas
    canvas = document.getElementById(&#39;myCanvas&#39;);
    // 2 - Get the context
    ctx=canvas.getContext(&#39;2d&#39;);
    // 3 - we can draw
    drawSomething();
    }
    function drawSomething() {
    // draw a red rectangle
    ctx.fillStyle=&#39;#FF0000&#39;;
    ctx.fillRect(0,0,80,100);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<h4>Explanations</h4>

<p><b>Only access elements when the DOM is ready:</b></p>

<p>Notice that we wrote an “init” function (<i>line 13</i>) that is called only when 
the page has been entirely loaded (we say “when the DOM is ready”). There are several 
ways to do this. In this example we used the &lt;body onload=“init();”&gt; method, at 
<i>line 29</i>.</p>

<p>It’s good practice to have such a function, as we cannot access the elements of the 
page before the page has been loaded entirely and before the DOM is ready.</p>

<p>Another way is to put the JavaScript code at the end of the document (between 
&lt;script&gt;…&lt;/script&gt;), right before the &lt;/body&gt;. In this case 
when the JavaScript code is executed,
the DOM has already been constructed.</p>

<p><b>Start by getting the canvas and the context:</b></p>

<p>Before drawing or doing anything interesting with the canvas, we must first 
get its drawing “context”. The drawing context defines the drawing methods and 
properties we can use.</p>

<p>Good practice is to get the canvas, the context, the width and height of the 
canvas and other global objects in this “init” function.</p>

<p><b>After the context is set, we can draw, but first let’s set the current color 
for filled shapes:</b></p>

<p>The example shows the use of the fillStyle property at <i>line 24</i> - useful 
for specifying the way shapes will be filled. In our case this line indicates the 
color of all the filled shapes we are going to draw:</p>

<pre>ctx.fillStyle=&#39;#FF0000&#39;;</pre>

<p>The context property named fillStyle is used here. This property can be set with a 
color, a gradient, or a pattern. We will see examples of these later on in the course.</p>

<p>The example says that all filled shapes will use the color “#FF0000”, which 
corresponds to a pure red color using the CSS RGB hexadecimal encoding (we could 
also have used ctx.fillStyle=‘red’);</p>

<p><b>Then we can draw:</b></p>

<pre>ctx.fillRect(0,0,80,100);</pre>

<p>This line is a call to the method fillRect(top left X coordinate, top left Y 
coordinate, width, height), which draws a filled rectangle.</p>
<p>The way the rectangle will be filled depends on the current value of several 
properties of the context, in particular the value of the fillStyle property. 
In our case, the rectangle will be red.</p>

<h4>Summary of the different steps:</h4>

<ol type="1">
  <li><b>Declare the canvas,</b> remembering to add an id attribute, and fallback content:</li>
</ol>

<pre>&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;
  ...fallback content...
&lt;/canvas&gt;</pre>

<ol start="2" type="1">
  <li><b>Get a reference to the canvas in a JavaScript variable</b> using the DOM API:</li>
</ol>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);</pre>

<ol start="3" type="1">
  <li><b>Get the context for drawing in that canvas</b>:</li>
</ol>

<pre>var ctx=canvas.getContext(&#39;2d&#39;);</pre>

<ol start="4" type="1">
  <li><b>Specify some drawing properties</b> (optional):  </li>
</ol>

<pre>ctx.fillStyle=&#39;#FF0000&#39;;</pre>

<ol start="5" type="1">
  <li><b>Draw some shapes</b>:</li>
</ol>

<pre>ctx.fillRect(0,0,80,100)</pre>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-7">3.2.7 Drawing Principles</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>More about the “context” object</h4>

<p>Before we go on, we should take some time to clarify the way we draw
on HTML5 canvases. We already mentioned that we use a graphic context
for all the main operations. Whenever a shape, a text, or an image is
drawn, the current values of the different properties of the graphic
context are taken into account. Some are relevant only for certain kinds
of shapes or drawing modes, but you must be aware that it is always the
current values of these drawing properties that are used.</p>
<p>Later on we’ll see that there are ways to save and restore this whole
set of values, but for now, let’s examine in greater detail some of the
properties and methods we’ve already encountered, and introduce new
ones.</p>

<h4>More about properties and methods of the context object</h4>

<ul>
  <li><b>fillStyle</b> is a property of the context, similar in a way to a CSS property</li>
</ul>

<h4>Its value can be one of the following:</h4>

<ul>
  <li>a color,</li>
  <li>a pattern (texture), or</li>
  <li>a gradient.</li>
</ul>

<p>The default value is the color black. Any kind of drawing in “fill
mode” will use the value of this property to determine how to render the
“filled part” of the drawing: any filled rectangle will be filled black
by default, any filled circle will be filled in black, and so on.</p>
<p>As long as we don’t modify the value of this property, all drawing
commands for filled shapes will use the current value.</p>
<p>Note that we will study in detail how to use colors, gradients and
patterns later, but for now we introduce some properties and values so
that you can understand the principles of canvas drawing.</p>
<p>fillStyle and the other context properties can be considered to be
“global variables” of the context.</p>

<ul>
  <li>fillRect(x, y, width, height):  a call to this method draws a filled rectangle</li>
</ul>

<p>The two first parameters are the coordinates of the top left corner
of the rectangle. This method uses the current value of
the fillStyle property to determine how to fill the rectangle.</p>

<pre>ctx.fillStyle=&#39;pink&#39;;
ctx.fillRect(10,10,200,200);</pre>

<p>Produces this result:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~ 128. filled rectangle with pink color (149) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image128.webp"
  loading="lazy"
  style="width:25%"
  title="Filled rectangle with pink color"
  alt="Filled rectangle with pink color." />

<ul>
  <li>strokeStyle is a property of the context similar to fillStyle, but this time for indicating how the shape’s outline should be rendered</li>
</ul>

<p>The possible values are the same as those for the fillStyle property:
a color, a pattern, or a gradient. This property will be taken into
account when wireframe shapes are drawn.</p>

<ul>
  <li>strokeRect(x, y, width, height): like fillRect(…), but instead of drawing a filled rectangle the rectangle is drawn in wireframe mode </li>
</ul>

<pre>ctx.strokeStyle=&#39;blue&#39;;
ctx.strokeRect(10,10,200,200);</pre>

<p>… gives this result:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~ 129. stroked rectangle - border is in blue (150) ~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image129.webp"
  loading="lazy"
  style="width:25%"
  title="Stroked rectangle - border is in blue"
  alt="Stroked rectangle - border is in blue." />

<p>Only the outline of the rectangle will be drawn, and it will be drawn
using the value of the strokeStyle property.</p>

<ul>
  <li><h4>clearRect(x, y, width, height): a call to this method erases the specified rectangle</h4></li>
</ul>

<p>Actually it draws it in a color called “transparent black” (!) that
corresponds to the initial state of the rectangle as if no drawing had
occurred.</p>

<pre>ctx.fillStyle=&#39;pink&#39;;
ctx.fillRect(10,10,200,200);
ctx.clearRect(50, 50, 20, 20);</pre>

<h4>The result is:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~ 130. the use of clearrrect draws a white rectangle against the pink background (151) ~~~-->
<img class="displayed"
  src="./images/image130.webp"
  loading="lazy"
  style="width:25%"
  title="The use of ClearRect draws a white rectangle against the pink background"
  alt="The use of ClearRect draws a white rectangle against the pink background." />

<h4>Let’s see some simple examples</h4>

<h4>Example #1: draw a wireframe red rectangle, width lineWidth = 3 pixels</h4>

<h4>Extract from the source code (the part that draws the rectangle):</h4>

<pre>function drawSomething() {
  // draw a red rectangle, line width=3 pixels
  ctx.lineWidth=3;
  ctx.strokeStyle=&#39;red&#39;;
  ctx.strokeRect(10,10,80,100);
}</pre>

<p>Here, we used "stroke" instead of "fill" in the property and method names 
(<i>lines 4 and 5</i>): strokeStyle instead of fillStyle, strokeRect(…) instead 
of fillRect(…).</p>

<p>We also introduced a new property of the context, that applies only when 
drawing in "stroke" mode, the lineWidth property (<i>line 3</i>), that is used 
for setting the width of the shape outline. The value is in pixels.</p>

<h4>Example #2: draw two filled red rectangles with a blue outline of 5 pixels and some text</h4>

<p>Let’s continue with another example. This time we will draw several shapes 
that share the same colors - they will be filled in red, with a blue outline. 
We also show how to draw a text message with a given font.</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Drawing with outline&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    function init() {
      // This function is called after the page is loaded
      // 1 - Get the canvas
      canvas = document.getElementById(&#39;myCanvas&#39;);
      // 2 - Get the context
      ctx=canvas.getContext(&#39;2d&#39;);
      // 3 - we can draw
      drawSomething();
    }
    function drawSomething() {
    // set the global context values
      ctx.lineWidth=5;
      ctx.fillStyle=&#39;red&#39;;
      ctx.strokeStyle=&#39;blue&#39;
      // font for all text drawing
      ctx.font = &#39;italic 20pt Calibri&#39;;
      // Draw the two filled red rectangles
      ctx.fillRect(10, 30, 70, 150);
      ctx.fillRect(110, 30, 70, 150);
      // Draw the two blue wireframe rectangles
      ctx.strokeRect(10, 30, 70, 150);
      ctx.strokeRect(110, 30, 70, 150);
      // Draw a message above the rectangles
      ctx.fillText(&quot;hello&quot;, 70, 22);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>function drawSomething() {
  // set the global context values
  ctx.lineWidth=5;
  ctx.fillStyle=&#39;red&#39;;
  ctx.strokeStyle=&#39;blue&#39;
  // font for all text drawing
  ctx.font = &#39;italic 20pt Calibri&#39;;

  // Draw the two filled red rectangles
  ctx.fillRect(10, 30, 70, 150);
  ctx.fillRect(110, 30, 70, 150);
 
  // Draw the two blue wireframe rectangles
  ctx.strokeRect(10, 30, 70, 150);
  ctx.strokeRect(110, 30, 70, 150);

  // Draw a message above the rectangles
  ctx.fillText(&quot;hello&quot;, 70, 22);
}</pre>

</details>

<p>This example shows the “global” nature of the context properties.
Once you set the filled color to red, any shapes you draw in filled mode
will be red. This is true for all the context properties. We set some of
these properties in <i>lines 3-7</i>, and all following calls to context
methods for drawing rectangles or text will depend on them. The two
filled rectangles at <i>lines 10-11</i> will be red, the two wireframe
rectangles drawn at <i>lines 14-15</i> will be blue, etc.</p>

<p><i>Line 18</i> shows how to draw a text message at an X position of
70 and a Y position of 22. The font is set at <i>line 7</i> using
the font property of the context.  The syntax is the same we use in CSS
for using “system fonts”.</p>

<p>If you would like to draw the filled text message in green, for example,
you should set the ctx.fillStyle property to “green” after you draw the
rectangles and before you draw the text (i.e just before <i>line 18</i>).</p>

<h4>Summary of what we’ve learned</h4>

<ul>
  <li>“stroke” means “wireframe” or “outlined”. It is a prefix for setting properties or calling methods that will affect wireframe shapes.</li>
  <li>“fill” is a prefix for filled shapes.</li>
  <li>To set the properties of wireframe shapes use ctx.<b>stroke</b>Style= …, for filled shapes use ctx.<b>fill</b>Style=… So far the values we have used are colors, expressed as strings. Example: ctx.strokeStyle  = ‘blue’;</li>
  <li>To draw a wireframe rectangle use ctx.strokeRect(x, y, width, height), to draw a filled rectangle use ctx.fillRect(x, y, width, height);</li>
  <li>To set the line width of wireframe shapes, use the ctx.lineWidth property. Example ctx.lineWidth = 10; ctx.strokeRect(0, 0, 100, 100);  will draw a 100x100 rectangle in wireframe mode, with an outline width of 10 pixels.</li>
  <li>To draw a text message use ctx.strokeText(message, x, y) or ctx.fillText(message, x, y), for wireframe text or filled text respectively.</li>
  <li>To set the character font use the ctx.font property; the value is a font in CSS syntax, for example:  ctx.font = ‘italic 20pt Calibri’; </li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-8">3.2.8 Transformations</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>We now introduce the basics of 2D transformations, a powerful tool that
will make things easier as soon as you have to:</p>

<ul>
  <li>Draw complex shapes at given positions, with given orientations and sizes,</li>
  <li>Draw shapes relative to one another.</li>
</ul>

<p>Let’s start with some simple examples before looking at how we use 2D transforms.</p>

<h4>Examples</h4>

<ul>
  <li>Let’s draw three rectangles!</li>
</ul>

<p>If we draw three rectangles of size 100x200 in a 400x400 canvas, one at (0, 0) and 
another at (150, 0), and a third at (300, 0), here is the result and the corresponding 
code:</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Let&#39;s draw three rectangles!&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    function init() {
      // This function is called after the page is loaded
      // 1 - Get the canvas
      canvas = document.getElementById(&#39;myCanvas&#39;);
      // 2 - Get the context
      ctx=canvas.getContext(&#39;2d&#39;);
      // 3 - we can draw
      drawSomething();
    }
    function drawSomething() {
      // draw a red rectangle
      ctx.fillStyle=&#39;lightgreen&#39;;
      ctx.fillRect(0,0,100,200);
      ctx.fillRect(150,0,100,200);
      ctx.fillRect(300,0,100,200);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>JavaScript code extract:</p>

<pre>function drawSomething() {
  ctx.fillStyle=&#39;lightgreen&#39;;
  ctx.fillRect(0,0,100,200);
  ctx.fillRect(150,0,100,200);
  ctx.fillRect(300,0,100,200);
}</pre>

<ul>
  <li>Let’s modify the code so that we can draw these rectangles at any X and Y position</li>
</ul>

<p>What if we wanted to draw these 3 rectangles at another position, as
a group? We would like to draw all of them a little closer to the
bottom, for example… Let’s add some parameters to the function:  the X
and Y position of the rectangles.</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
  &lt;title&gt;Draw 3 rectangles at any X and Y position&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    function init() {
      // This function is called after the page is loaded
      // 1 - Get the canvas
      canvas = document.getElementById(&#39;myCanvas&#39;);
      // 2 - Get the context
      ctx=canvas.getContext(&#39;2d&#39;);
      // 3 - we can draw
      drawSomething(0, 100);
    }
    function drawSomething(x, y) {
       // draw a red rectangle
       ctx.fillStyle=&#39;lightgreen&#39;;
       ctx.fillRect(x,y,100,200);
       ctx.fillRect(x+150,y,100,200);
       ctx.fillRect(x+300,y,100,200);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>var canvas, ctx;
 
function init() {
  // This function is called after the page is loaded
  // 1 - Get the canvas
  canvas = document.getElementById(&#39;myCanvas&#39;);
  // 2 - Get the context
  ctx=canvas.getContext(&#39;2d&#39;);
  // 3 - we can draw
  drawSomething(0, 100);
}

function drawSomething(x, y) {
  // draw 3 rectangles
  ctx.fillStyle=&#39;lightgreen&#39;;
  ctx.fillRect(x,y,100,200);
  ctx.fillRect(x+150,y,100,200);
  ctx.fillRect(x+300,y,100,200);
}</pre>

</details>

<p>At <i>line 10</i>, we called the drawSomething(…) function with 0 and
100 as parameters, meaning “please add an offset of 0 in X and 100 in Y
directions to what is drawn by the function…</p>
<p>If you look at the code of the modified function, you will see
that each call to fillRect(…) uses the x and y parameters instead of
hard coded values. In this way, if we call it with parameters (0, 100),
then all rectangles will be drawn 100 pixels to the bottom (offset in
y). Here is the result:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~ 131. Rectangles are drawn 100 pixels towards the bottom (156) ~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image131.webp"
  loading="lazy"
  style="width:30%"
  title="Rectangles are drawn 100 pixels towards the bottom"
  alt="Rectangles are drawn 100 pixels towards the bottom." />
  
<ul>
  <li>Now, let’s draw a small monster’s head with rectangles</li>
</ul>

<p>Now we can start having some fun… let’s draw a monster’s head using only rectangles:</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;Monster&#39;s head with rectangles&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;style&gt;
#myCanvas {
border: 1px solid black;
}
&lt;/style&gt;
&lt;script&gt;
var canvas, ctx;
function init() {
// This function is called after the page is loaded
// 1 - Get the canvas
canvas = document.getElementById(&#39;myCanvas&#39;);
// 2 - Get the context
ctx=canvas.getContext(&#39;2d&#39;);
// 3 - we can draw
drawMonster(0, 0);
}
function drawMonster(x, y) {
// draw a red rectangle
// head
ctx.fillStyle=&#39;lightgreen&#39;;
ctx.fillRect(x,y,200,200);
// eyes
ctx.fillStyle=&#39;red&#39;;
ctx.fillRect(x+35,y+30,20,20);
ctx.fillRect(x+140,y+30,20,20);
// interior of eye
ctx.fillStyle=&#39;yellow&#39;;
ctx.fillRect(x+43,y+37,10,10);
ctx.fillRect(x+143,y+37,10,10);
// Nose
ctx.fillStyle=&#39;black&#39;;
ctx.fillRect(x+90,y+70,20,80);
// Mouth
ctx.fillStyle=&#39;purple&#39;;
ctx.fillRect(x+60,y+165,80,20);
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
Your browser does not support the canvas tag.
&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>function drawMonster(x, y) {
  // head
  ctx.fillStyle=&#39;lightgreen&#39;;
  ctx.fillRect(x,y,200,200);

  // eyes
  ctx.fillStyle=&#39;red&#39;;
  ctx.fillRect(x+35,y+30,20,20);
  ctx.fillRect(x+140,y+30,20,20);

  // interior of eye
  ctx.fillStyle=&#39;yellow&#39;;
  ctx.fillRect(x+43,y+37,10,10);
  ctx.fillRect(x+143,y+37,10,10);

  // Nose
  ctx.fillStyle=&#39;black&#39;;
  ctx.fillRect(x+90,y+70,20,80);

  // Mouth
  ctx.fillStyle=&#39;purple&#39;;
  ctx.fillRect(x+60,y+165,80,20);
}</pre>

</details>

<p>As you can see, the code uses the same technique, becomes less and less readable. 
The Xs and Ys at the beginning of each call makes understanding the code harder, etc.
However, there is a way to simplify this =&gt; 2D geometric transformations!</p>

<h4>Geometric transformations: changing the coordinate system</h4>

<p>The idea behind 2D transformations is that instead of modifying all the 
coordinates passed as parameters to each call to drawing methods like fillRect(…), 
we will keep all the drawing code "as is". For example, if the monster of our 
previous example was drawn at (0, 0), we could just translate (or rotate, or 
scale) the original coordinate system.</p>

<p>Let’s take a piece of code that draws something corresponding to the original 
coordinate system, located at the top left corner of the canvas:</p>

<details>
  <summary><b>CSS source code:</b></summary>
  
<pre>function drawMonster(x, y) {
  // head
  ctx.fillStyle=&#39;lightgreen&#39;;
  ctx.fillRect(0,0,200,200);
 
  // eyes
  ctx.fillStyle=&#39;red&#39;;
  ctx.fillRect(35,30,20,20);
  ctx.fillRect(140,30,20,20);

  // interior of eye
  ctx.fillStyle=&#39;yellow&#39;;
  ctx.fillRect(43,37,10,10);
  ctx.fillRect(143,37,10,10);

  // Nose
  ctx.fillStyle=&#39;black&#39;;
  ctx.fillRect(90,70,20,80);

  // Mouth
  ctx.fillStyle=&#39;purple&#39;;
  ctx.fillRect(60,165,80,20);

  // coordinate system at (0, 0)
  drawArrow(ctx, 0, 0, 100, 0, 10, &#39;red&#39;);
  drawArrow(ctx, 0, 0, 0, 100, 10, &#39;red&#39;);
}</pre>

</details>

<p>This code is the just the same as in the previous example except that
we removed all Xs and Yx in the code. We also added at the end (<i>lines
25-26</i>) two lines of code that draw the coordinate system.
The drawArrow(startX, startY, endX, endY, width, color) function is a
utility function that we will present later. You can see it in the
JavaScript source code of the pen below:</p>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>// Borrowed and adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
//variables to be used when creating the arrow
var headlen = 10;
var angle = Math.atan2(toy-fromy,tox-fromx);
ctx.save();
ctx.strokeStyle = color;
//starting path of the arrow from the start square to the end square and drawing the stroke
ctx.beginPath();
ctx.moveTo(fromx, fromy);
ctx.lineTo(tox, toy);
ctx.lineWidth = arrowWidth;
ctx.stroke();
//starting a new path from the head of the arrow to one of the sides of the point
ctx.beginPath();
ctx.moveTo(tox, toy);
ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
//path from the side point of the arrow, to the other side point
ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));
//path from the side point back to the tip of the arrow, and then again to the opposite side point
ctx.lineTo(tox, toy);
ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
//draws the paths created above
ctx.stroke();
ctx.restore();
}</pre>

</details>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;Monster&#39;s head drawn with 2D transformations&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;style&gt;
#myCanvas {
border: 1px solid black;
}
&lt;/style&gt;
&lt;script&gt;
var canvas, ctx;
function init() {
// This function is called after the page is loaded
// 1 - Get the canvas
canvas = document.getElementById(&#39;myCanvas&#39;);
// 2 - Get the context
ctx=canvas.getContext(&#39;2d&#39;);
// 3 - we can draw, try to change these values
drawMonster(0, 0);
}
function drawMonster(x, y) {
// head
ctx.fillStyle=&#39;lightgreen&#39;;
ctx.fillRect(0,0,200,200);
// eyes
ctx.fillStyle=&#39;red&#39;;
ctx.fillRect(35,30,20,20);
ctx.fillRect(140,30,20,20);
// interior of eye
ctx.fillStyle=&#39;yellow&#39;;
ctx.fillRect(43,37,10,10);
ctx.fillRect(143,37,10,10);
// Nose
ctx.fillStyle=&#39;black&#39;;
ctx.fillRect(90,70,20,80);
// Mouth
ctx.fillStyle=&#39;purple&#39;;
ctx.fillRect(60,165,80,20);
// coordinate system at (0, 0)
drawArrow(ctx, 0, 0, 100, 0, 10, &#39;red&#39;);
drawArrow(ctx, 0, 0, 0, 100, 10, &#39;red&#39;);
}
&lt;/script&gt;</pre>

</details>

<p>Note that the X and Y parameters are useless for now…</p>

<pre>Translation using ctx.translate(offsetX, offsetY)</pre>

<p>Now, instead of simply calling drawMonster(0, 0), we will call
first ctx.translate(100, 100), and look at the result below:</p>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>// Borrowed and adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
  //variables to be used when creating the arrow
  var headlen = 10;
  var angle = Math.atan2(toy-fromy,tox-fromx);
  ctx.save();
  ctx.strokeStyle = color;
  //starting path of the arrow from the start square to the end square and drawing the stroke
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineWidth = arrowWidth;
  ctx.stroke();
  //starting a new path from the head of the arrow to one of the sides of the point
  ctx.beginPath();
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //path from the side point of the arrow, to the other side point
  ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));
  //path from the side point back to the tip of the arrow, and then again to the opposite side point
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //draws the paths created above
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;Translated monster&#39;s head&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;style&gt;
  #myCanvas {
    border: 1px solid black;
  }
&lt;/style&gt;
&lt;script&gt;
  var canvas, ctx;
  function init() {
    // This function is called after the page is loaded
    // 1 - Get the canvas
    canvas = document.getElementById(&#39;myCanvas&#39;);
    // 2 - Get the context
    ctx=canvas.getContext(&#39;2d&#39;);
    // 3 - we can draw, try to change these values
    ctx.translate(100, 100);
    drawMonster(0, 0);
  }

  function drawMonster(x, y) {
    // head
    ctx.fillStyle=&#39;lightgreen&#39;;
    ctx.fillRect(0,0,200,200);
    // eyes
    ctx.fillStyle=&#39;red&#39;;
    ctx.fillRect(35,30,20,20);
    ctx.fillRect(140,30,20,20);
    // interior of eye
    ctx.fillStyle=&#39;yellow&#39;;
    ctx.fillRect(43,37,10,10);
    ctx.fillRect(143,37,10,10);
    // Nose
    ctx.fillStyle=&#39;black&#39;;
    ctx.fillRect(90,70,20,80);
    // Mouth
    ctx.fillStyle=&#39;purple&#39;;
    ctx.fillRect(60,165,80,20);
    // coordinate system at (0, 0)
    drawArrow(ctx, 0, 0, 100, 0, 10, &#39;red&#39;);
    drawArrow(ctx, 0, 0, 0, 100, 10, &#39;red&#39;);
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>JavaScript code extract:</h4>

<pre>ctx.translate(100, 100);
drawMonster(0, 0);</pre>

<p><i>Line 1</i> changes the position of the coordinate system, <i>line
2</i> draws a monster in the new translated coordinate system. All
subsequent calls to drawing methods will be affected and will work in
this new system too.</p>

<ul>
  <li><h4>Other transformations: rotate, scale</h4></li>
</ul>

<h5>There are other transformations available:</h5>

<ul>
  <li>ctx.rotate(angle), with angle in radians. Note that the order of transformations is important: usually we translate, then rotate, then scale… If you change this order, you need to know what you are doing…</li>
  <li>ctx.scale (sx, sy), where scale(1, 1) corresponds to “no zoom”, scale(2, 2) corresponds to “zooming 2x” and scale(0.5, 0.5) corresponds to zooming out to see the drawings half as big as before. If you do not use the same values for sx and sy, you do “asymmetric scaling”, you can distort a shape horizontally or vertically. Try changing the values in the source code of the next online examples.</li>
</ul>

<p>Here is the previous example, but this time we translated the coordinate system, then rotated it with an angle equal to PI/4 , then we scaled it so that units are half as big:</p>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>// Borrowed and adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
  //variables to be used when creating the arrow
  var headlen = 10;
  var angle = Math.atan2(toy-fromy,tox-fromx);
  ctx.save();
  ctx.strokeStyle = color;
  //starting path of the arrow from the start square to the end square and drawing the stroke
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineWidth = arrowWidth;
  ctx.stroke();
  //starting a new path from the head of the arrow to one of the sides of the point
  ctx.beginPath();
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //path from the side point of the arrow, to the other side point
  ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));
  //path from the side point back to the tip of the arrow, and then again to the opposite side point
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //draws the paths created above
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;Translated, rotated, and scaled monster&#39;s head&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;style&gt;
#myCanvas {
border: 1px solid black;
}
&lt;/style&gt;
&lt;script&gt;
  var canvas, ctx;
  function init() {
    // This function is called after the page is loaded
    // 1 - Get the canvas
    canvas = document.getElementById(&#39;myCanvas&#39;);
    // 2 - Get the context
    ctx=canvas.getContext(&#39;2d&#39;);
    // 3 - we can draw, try to change these values
    ctx.translate(100, 100);
    ctx.rotate(Math.PI/4);
    ctx.scale(0.5, 0.5);
    drawMonster(0, 0);
  }

  function drawMonster(x, y) {
    // head
    ctx.fillStyle=&#39;lightgreen&#39;;
    ctx.fillRect(0,0,200,200);
    // eyes
    ctx.fillStyle=&#39;red&#39;;
    ctx.fillRect(35,30,20,20);
    ctx.fillRect(140,30,20,20);
    // interior of eye
    ctx.fillStyle=&#39;yellow&#39;;
    ctx.fillRect(43,37,10,10);
    ctx.fillRect(143,37,10,10);
    // Nose
    ctx.fillStyle=&#39;black&#39;;
    ctx.fillRect(90,70,20,80);
    // Mouth
    ctx.fillStyle=&#39;purple&#39;;
    ctx.fillRect(60,165,80,20);
    // coordinate system at (0, 0)
    drawArrow(ctx, 0, 0, 100, 0, 10, &#39;red&#39;);
    drawArrow(ctx, 0, 0, 0, 100, 10, &#39;red&#39;);
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>And here is the code of the transformations we used, followed by the call to the function that draws the monster:</h4>

<pre>ctx.translate(100, 100);
ctx.rotate(Math.PI/4);
ctx.scale(0.5, 0.5);
 
drawMonster(0, 0);</pre>

<ul>
  <li><h4>BEWARE: all drawings to come will be in that modified coordinate system!</h4></li>
</ul>

<p>If we draw two shapes at two different positions, they will be relative to this new coordinate system.</p>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>// Borrowed and adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
//variables to be used when creating the arrow
var headlen = 10;
var angle = Math.atan2(toy-fromy,tox-fromx);
  ctx.save();
  ctx.strokeStyle = color;
  //starting path of the arrow from the start square to the end square and drawing the stroke
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineWidth = arrowWidth;
  ctx.stroke();
  //starting a new path from the head of the arrow to one of the sides of the point
  ctx.beginPath();
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //path from the side point of the arrow, to the other side point
  ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));
  //path from the side point back to the tip of the arrow, and then again to the opposite side point
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //draws the paths created above
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;2D transformation&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;style&gt;
      #myCanvas {
        border: 1px solid black;
      }
    &lt;/style&gt;
    &lt;script&gt;
      var canvas, ctx;
      function init() {
        // This function is called after the page is loaded
        // 1 - Get the canvas
        canvas = document.getElementById(&#39;myCanvas&#39;);
        // 2 - Get the context
        ctx=canvas.getContext(&#39;2d&#39;);
        // 3 - we can draw, try to change these values
        ctx.translate(100, 100);
        ctx.rotate(Math.PI/4);
        ctx.scale(0.5, 0.5);
        // Draw the monster at (0, 0)
        drawMonster(0, 0);
        // draw a filled rectagle at (250, 0)
        ctx.fillRect(250, 0, 100, 100);
        drawCoordinateSystem(&#39;red&#39;, 10);
      }
      function drawMonster(x, y) {
        // head
        ctx.fillStyle=&#39;lightgreen&#39;;
        ctx.fillRect(0,0,200,200);
        // eyes
        ctx.fillStyle=&#39;red&#39;;
        ctx.fillRect(35,30,20,20);
        ctx.fillRect(140,30,20,20);
        // interior of eye
        ctx.fillStyle=&#39;yellow&#39;;
        ctx.fillRect(43,37,10,10);
        ctx.fillRect(143,37,10,10);
        // Nose
        ctx.fillStyle=&#39;black&#39;;
        ctx.fillRect(90,70,20,80);
        // Mouth
        ctx.fillStyle=&#39;purple&#39;;
        ctx.fillRect(60,165,80,20);
      }
      function drawCoordinateSystem(color, width) {
        // coordinate system at (0, 0)
        drawArrow(ctx, 0, 0, 100, 0, width, color);
        drawArrow(ctx, 0, 0, 0, 100, width, color);
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;init();&quot;&gt;
    &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
      Your browser does not support the canvas tag.
    &lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<pre>ctx.translate(100, 100);
ctx.rotate(Math.PI/4);
ctx.scale(0.5, 0.5);
// Draw the monster at (0, 0)
drawMonster(0, 0);
// Draw a filled rectagle at (250, 0)
ctx.fillRect(250, 0, 100, 100);</pre>

<h4>How can we reset the coordinate system, how can we go back to the previous one?</h4>

<p>Aha, this is a very interesting question… the answer is in the next
page!</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-2-9">3.2.9 Saving and Restoring the Context</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>There are two methods for saving and restoring the context
properties: ctx.save() and ctx.restore().</p>
<p>What will be saved: fillStyle and strokeStyle, lineWidth, the
previous coordinate system, etc. <b>Meaning that ALL properties that
affect drawing!</b></p>
<p>A call to ctx.save() will probably save the context property values
in a hardware register on your graphics card. Multiple contexts can be
saved consecutively and restored.</p>
<p>Multiple contexts can be backed up consecutively and restored.
Contexts saved will be stacked, the last one that has been saved will be
restored by the next call to restore(), so it is very important to have
one restore for each save.</p>
<p><b>Best practice</b>: save the context at the beginning of any
function <i>that changes the context, restore it at the end of the
function!</i></p>

<h4>Example of a function that changes the context and restores it after execution</h4>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>// Borrowed and adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
  //variables to be used when creating the arrow
  var headlen = 10;
  var angle = Math.atan2(toy-fromy,tox-fromx);
  ctx.save();
  ctx.strokeStyle = color;
  //starting path of the arrow from the start square to the end square and drawing the stroke
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineWidth = arrowWidth;
  ctx.stroke();
  //starting a new path from the head of the arrow to one of the sides of the point
  ctx.beginPath();
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //path from the side point of the arrow, to the other side point
  ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));
  //path from the side point back to the tip of the arrow, and then again to the opposite side point
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));
  //draws the paths created above
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Saving and restoring the context&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    function init() {
    // This function is called after the page is loaded
    // 1 - Get the canvas
    canvas = document.getElementById(&#39;myCanvas&#39;);
    // 2 - Get the context
    ctx=canvas.getContext(&#39;2d&#39;);
    // 3 - we can draw, try to change these values
    drawMonster(200, 100, Math.PI/4, &#39;lightGreen&#39;, &#39;yellow&#39;);
    // draw another rectangle at (0, 0), you will see it&#39;s black
    // (default color), and at the top left corner of the canvas
    // (original position of the coordinate system)
    ctx.fillRect(0, 0, 80, 80);
    }  /* function init() */
  function drawMonster(x, y, angle, headColor, eyeColor) {
    // GOOD PRACTICE : SAVE CONTEXT AND RESTORE IT AT THE END
    ctx.save();
    // Moves the coordinate system so that the monster is drawn
    // at position (x, y)
    ctx.translate(x, y);
    ctx.rotate(angle)
    // head
    ctx.fillStyle=headColor;
    ctx.fillRect(0,0,200,200);
    // eyes
    ctx.fillStyle=&#39;red&#39;;
    ctx.fillRect(35,30,20,20);
    ctx.fillRect(140,30,20,20);
    // interior of eye
    ctx.fillStyle=eyeColor;
    ctx.fillRect(43,37,10,10);
    ctx.fillRect(143,37,10,10);
    // Nose
    ctx.fillStyle=&#39;black&#39;;
    ctx.fillRect(90,70,20,80);
    // Mouth
    ctx.fillStyle=&#39;purple&#39;;
    ctx.fillRect(60,165,80,20);
    // coordinate system at (0, 0)
    drawArrow(ctx, 0, 0, 100, 0, 10, &#39;red&#39;);
    drawArrow(ctx, 0, 0, 0, 100, 10, &#39;red&#39;);
    // GOOD PRACTICE !
    ctx.restore();
    }  /* function drawMonster () */
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>We slightly modified the function that draws the monster:</p>

<ul>
  <li>We added parameters for setting the position and orientation of the monster, and 
    added calls to ctx.translate(x, y) and ctx.rotate(angle) in the function.</li>
  <li>We added parameters for the head color and eye color.</li>
  <li>We saved the context at the beginning of the function (BEST PRACTICE),</li>
  <li>We restored it at the end (BEST PRACTICE).</li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 132. monster head example (167) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image132.webp"
  loading="lazy"
  style="width:40%"
  title="Example of context save-restore: a monster drawn by a function that saves 
    and restored the context, then a rectangle is drawn, with context as it was previously"
  alt="Example of context save-restore: a monster drawn by a function that saves 
    and restored the context, then a rectangle is drawn, with context as it was previously." />

<p>Source code extract of this function: notice at <i>lines 3</i> and <i>26</i> 
how we save/restore the context at the beginning/end. Right after saving the 
context, we modify the coordinate system (<i>lines 7-8</i>). The rest of the 
code is nearly the same as in the last version of the monster example.</p>

<h4>function drawMonster</h4>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>function drawMonster(x, y, angle, headColor, eyeColor) {
  // BEST PRACTICE: SAVE CONTEXT AND RESTORE IT AT THE END
  ctx.save();
  // Moves the coordinate system so that the monster is drawn
  // at position (x, y)
  ctx.translate(x, y);
  ctx.rotate(angle);
  // head
  ctx.fillStyle=headColor;
  ctx.fillRect(0,0,200,200);
  // eyes
  ctx.fillStyle=&#39;red&#39;;
  ctx.fillRect(35,30,20,20);
  ctx.fillRect(140,30,20,20);
  // interior of eye
  ctx.fillStyle=eyeColor;
  ctx.fillRect(43,37,10,10);
  ctx.fillRect(143,37,10,10);
  ...
  // BEST PRACTICE!
  ctx.restore();
}</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-3-1">3.3.1 Immediate Mode</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>In the previous sections, we learned how to draw filled or wireframe rectangles.</p>
<p>As soon as the ctx.strokeRect(x, y, width, height) or the ctx.fillRect(x, y, width, height) 
method is called, a rectangle is indeed drawn <i>immediately</i> in the canvas.</p>
<p>While drawing rectangles with strokeRect or fillRect, drawing text or drawing 
images, all these shapes will be drawn in <i>immediate mode</i>.</p>
<p>Another mode called “path mode” or “buffered mode” will be seen later in this 
course, which will be useful for drawing lines, curves, arcs, and also rectangles. 
Rectangles are the only shapes that have methods for drawing them <i>immediately</i> 
and also other methods for drawing them in “<i>path/buffered mode</i>”.</p>

<h4>Example: drawing rectangles in immediate mode using best practices</h4>

<p>Let’s give an example that draws several rectangles, filled or wireframe, with 
different colors and line widths:</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Immediate mode&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    window.onload = function () {
      canvas = document.getElementById(&#39;myCanvas&#39;);
      ctx = canvas.getContext(&#39;2d&#39;);
      // black rectangle, default color (black)
      ctx.fillRect(10, 10, 100, 100);
      // outlined rectangle, default color
      ctx.strokeRect(150, 10, 100, 100);
      // outlined rectangle filled in red, outline blue
      ctx.fillStyle = &#39;red&#39;;
      ctx.strokeStyle = &#39;lightBlue&#39;;
      ctx.lineWidth = 10;
      ctx.fillRect(100, 150, 150, 150);
      ctx.strokeRect(100, 150, 150, 150);
      // A function to automatize previous drawing
      var angle = Math.PI / 10;
      drawFilledRectangle(300, 150, 150, 150, &#39;pink&#39;, &#39;green&#39;, 10, angle);
      drawFilledRectangle(300, 150, 150, 150, &#39;yellow&#39;, &#39;purple&#39;, 10, angle + 0.5);
    };
    function drawFilledRectangle(x, y, w, h, fillColor, strokeColor, lw, angle) {
      // GOOD PRACTICE : save if the function change the context or coordinate
      // system
      ctx.save();
      // position coordinate system
      ctx.translate(x, y);
      ctx.rotate(angle);
      // set colors, line width...
      ctx.lineWidth = lw;
      ctx.fillStyle = fillColor;
      ctx.strokeStyle = strokeColor;
      // draw at 0, 0 as we translated the coordinate
      // system already
      ctx.fillRect(0, 0, w, h);
      ctx.strokeRect(0, 0, w, h);
      // GOOD PRACTICE : a restore for a save!
      ctx.restore();
      }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;578&quot; height=&quot;400&quot;&gt;
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-3-2">3.3.2 Drawing Text</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The canvas API provides two main methods for drawing text: ctx.strokeText(message, x, y) and 
ctx.fillText(message, x, y). It also provides a set of context properties for setting the 
character font and style, for laying out the text, etc.</p>

<h4>Typical use</h4>

<p>Look at the example below, and change the position where the text is drawn, change 
font attributes, etc.:</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Drawing text&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot; width=500 height=300&gt;Your browser 
      does not support the canvas tag.&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      var canvas=document.getElementById(&#39;myCanvas&#39;);
      var context=canvas.getContext(&#39;2d&#39;);
      context.font = &quot;60pt Calibri&quot;;
      context.lineWidth = 3;
      context.strokeStyle = &quot;blue&quot;;
      context.fillStyle = &quot;red&quot;;
      context.fillText(&quot;Hello World!&quot;, 10, 100);
      context.strokeText(&quot;Hello World!&quot;, 10, 100);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Source code extract:</h4>

<pre>context.font = &quot;60pt Calibri&quot;;
// .. set color, lineWidth, shadow etc.
// 10, 10 is the start of the baseline, bottom of left leg of the &quot;H&quot; in the
// &quot;Hello World&quot; example.
context.fillText(&quot;Hello World!&quot;, 10, 10);
// Or
context.strokeText(&quot;Hello World!&quot;, 10, 10);</pre>

<h4>Properties and methods useful for drawing text</h4>

<h4>Choosing the font: the context.font property</h4>

<p>It is possible to draw text in a canvas using the font property of
the context to specify the font style (plain, bold, italic), the size,
and the font name. Other properties such as strokeStyle or fillStyle, as
well as other properties that are detailed in the next pages, are also
going to be taken into account.</p>

<p>The font property accepts values like: font-style,  font-weight, font-size, font-face.</p>

<h4>Accepted values are:</h4>

<ul>
  <li>font-style: normal, italic, oblique, </li>
  <li>font-weight: normal, bold, bolder, lighter,</li>
  <li>font-size: a size in pixels or in points, such as 60pt, 20px, 36px, etc.,</li>
  <li>font-face:  Arial, Calibri, Times, Courier, etc. Some font faces may not work in all browsers.</li>
</ul>

<h4>Examples:</h4>

<ul>
  <li>context.font = “60pt Calibri”;</li>
  <li>context.font = “normal normal 20px Verdana”;</li>
  <li>context.font = “normal 36px Arial”;</li>
  <li>context.font = “italic bold 36px Arial”;</li>
</ul>

<h4>Drawing text in solid or wireframe: the fillText() or strokeText() methods</h4>

<p>The fillText(message, x, y) or strokeText(message, x, y) methods from
the context will actually draw a text message at the origin of the
baseline position. In the “Hello World” example, this is located at the
bottom of the left leg of the “H”.</p>
<p>There is a fourth optional parameter maxWidth that forces the text to
fit into a given width, distorting it if necessary:</p>

<pre>context.strokeText(&quot;Hello World!&quot;, x, y [, maxWidth]);
context.fillText(&quot;Hello World!&quot;, x, y [, maxWidth]);</pre>

<h4>Forcing a text not to exceed a certain width: the maxWidth property</h4>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Drawing text: the maxWidth property&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=500 height=300&gt;Your browser 
    does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var context=canvas.getContext(&#39;2d&#39;);
    context.font = &quot;60pt Calibri&quot;;
    context.lineWidth = 3;
    context.strokeStyle = &quot;blue&quot;;
    context.fillStyle = &quot;red&quot;;
    context.fillText(&quot;Hello World!&quot;, 10, 100);
    context.strokeText(&quot;Hello World!&quot;, 10, 100);
    // Draw text with constrained width
    context.fillText(&quot;Hello World!&quot;, 10, 160, 250);
    context.strokeText(&quot;Hello World!&quot;, 10, 160, 250);
    context.fillText(&quot;Hello World!&quot;, 10, 220, 150);
    context.strokeText(&quot;Hello World!&quot;, 10, 220, 150);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>...
context.font = &quot;60pt Calibri&quot;;
context.lineWidth = 3;
context.strokeStyle = &quot;blue&quot;;
context.fillStyle = &quot;red&quot;;

context.fillText(&quot;Hello World!&quot;, 10, 100);
context.strokeText(&quot;Hello World!&quot;, 10, 100);

// Draw text with constrained width of 250 pixels
context.fillText(&quot;Hello World!&quot;, 10, 160, 250);
context.strokeText(&quot;Hello World!&quot;, 10, 160, 250);

// Constrain width to 150 pixels
context.fillText(&quot;Hello World!&quot;, 10, 220, 150);
context.strokeText(&quot;Hello World!&quot;, 10, 220, 150);</pre>

</details>

<h4>Measuring the width of a given text (bounding box) with the ctx.measureText()method</h4>

<p>The ctx.measureText() method can be used to get the current width in
pixels of a given text, taking into account the diverse properties
involved such as font, size, shadow, lineWidth, etc.</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Drawing text: the ctx.measureText() method&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=500 height=300&gt;Your browser 
    does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var context=canvas.getContext(&#39;2d&#39;);
    context.font = &quot;60pt Calibri&quot;;
    context.lineWidth = 3;
    context.strokeStyle = &quot;blue&quot;;
    context.fillStyle = &quot;red&quot;;
    context.fillText(&quot;Hello World!&quot;, 10, 100);
    context.strokeText(&quot;Hello World!&quot;, 10, 100);
    var textMetrics = context.measureText(&quot;Hello World!&quot;);
    var width = textMetrics.width;
    context.font = &quot;20pt Arial&quot;;
    context.fillText(&quot;Width of previous text: &quot; + width 
  + &quot;pixels&quot;, 10, 150);
    // Draw the baseline of the given width
    context.moveTo(10, 100);
    context.lineTo(width+10, 100);
    context.stroke();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>
  
<pre>context.font = &quot;60pt Calibri&quot;;
context.lineWidth = 3;
context.strokeStyle = &quot;blue&quot;;
context.fillStyle = &quot;red&quot;;
context.fillText(&quot;Hello World!&quot;, 10, 100);
context.strokeText(&quot;Hello World!&quot;, 10, 100);
var textMetrics = context.measureText(&quot;Hello World!&quot;);
var width = textMetrics.width;
// Draw a text that displays the width of the previous drawn text
context.font = &quot;20pt Arial&quot;;
context.fillText(&quot;Width of previous text: &quot; 
  + width + &quot;pixels&quot;, 10, 150);
// Draw the baseline of the given width
context.moveTo(10, 100);
context.lineTo(width+10, 100);
context.stroke();</pre>

</details>

<h4>Changing the way the text is horizontally drawn: the ctx.textbaseline property</h4>

<p>The textBaseline property of the context is used to specify the
different ways one can position the baseline of a given text:</p>

<details>
  <summary><b>HTML source code:</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Drawing text: the ctx.textbaseline property&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=500 height=300&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var context=canvas.getContext(&#39;2d&#39;);
    context.strokeStyle = &quot;#000000&quot;;
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo( 0, 75);
    context.lineTo(500, 75);
    context.stroke();
    context.closePath();
    context.font = &quot;16px Verdana&quot;;
    context.fillStyle = &quot;#000000&quot;;
    context.textBaseline = &quot;top&quot;;
    context.fillText(&quot;top&quot;, 0, 75);
    context.textBaseline = &quot;hanging&quot;;
    context.fillText(&quot;hanging&quot;, 40, 75);
    context.textBaseline = &quot;middle&quot;;
    context.fillText(&quot;middle&quot;, 120, 75);
    context.textBaseline = &quot;alphabetic&quot;;
    context.fillText(&quot;alphabetic&quot;, 200, 75);
    context.textBaseline = &quot;ideographic&quot;;
    context.fillText(&quot;ideographic&quot;, 300, 75);
    context.textBaseline = &quot;bottom&quot;;
    context.fillText(&quot;bottom-glyph&quot;, 400, 75);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>The example above shows the different possible values for this property and 
the corresponding results. The default value is "alphabetic" and corresponds to 
what has been used in the previous "Hello World" example.</p>

<h3>Possible values for the textbaseline property:</h3>

<pre>&lt;div data-align="center"&gt;
&lt;table&gt;
  &lt;colgroup&gt;
    &lt;col style="width: 30%" /&gt;
    &lt;col style="width: 69%" /&gt;
  &lt;/colgroup&gt;
&lt;thead&gt;
  &lt;tr class="header"&gt;
    &lt;th&gt;textBaseline property&lt;/th&gt;
    &lt;th&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;top&lt;/td&gt;
    &lt;td&gt;The text is aligned based on the top of the tallest glyph in the text.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;hanging&lt;/td&gt;
    &lt;td&gt;The text is aligned based on the line the text seems to hang from.  This 
      is almost identical to top, and in many cases, you cannot see the difference.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;middle&lt;/td&gt;
    &lt;td&gt;The text is aligned according to the middle of the text.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;alphabetic&lt;/td&gt;
    &lt;td&gt;The bottom of vertically oriented glyphs, e.g. western alphabet like the Latin.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="odd"&gt;
    &lt;td&gt;ideographic&lt;/td&gt;
    &lt;td&gt;The bottom of horizontally oriented glyphs.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="even"&gt;
    &lt;td&gt;bottom&lt;/td&gt;
    &lt;td&gt;The text is aligned based on the bottom of the glyph in the text, that 
      extends furthest down in the text.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</pre>

<p>Typical use (taken from the example above):</p>

<pre>context.textBaseline = &quot;top&quot;;
context.fillText(&quot;top&quot;, 0, 75);
context.textBaseline = &quot;hanging&quot;;
context.fillText(&quot;hanging&quot;, 40, 75);
context.textBaseline = &quot;middle&quot;;
context.fillText(&quot;middle&quot;, 120, 75);</pre>

<h4>Setting the horizontal justification of a text with the textAlign property</h4>

<p>The textAlign property of the context tells how the x parameter will be used when 
calling strokeText("some text", x, y) and fillText("some text", x, y). For example, 
with textAlign=“center”, the x parameter gives the position of the vertical center 
of the text, while in textAlign=“right”, x corresponds to the rightmost position 
of the text.</p>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Drawing text: the textAlign property&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=500 height=120&gt;Your browser 
    does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var context=canvas.getContext(&#39;2d&#39;);
    context.stokeStyle = &quot;#000000&quot;;
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo( 250, 0);
    context.lineTo( 250, 130);
    context.stroke();
    context.closePath();
    context.font = &quot;16px Verdana&quot;;
    context.fillStyle = &quot;#000000&quot;;
    context.textAlign = &quot;center&quot;;
    context.fillText(&quot;center&quot;, 250, 20);
    context.textAlign = &quot;start&quot;;
    context.fillText(&quot;start&quot;, 250, 40);
    context.textAlign = &quot;end&quot;;
    context.fillText(&quot;end&quot;, 250, 60);
    context.textAlign = &quot;left&quot;;
    context.fillText(&quot;left&quot;, 250, 80);
    context.textAlign = &quot;right&quot;;
    context.fillText(&quot;right&quot;, 250, 100);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Typical use (source code taken from the above example):</h4>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>context.textAlign = &quot;center&quot;;
context.fillText(&quot;center&quot;, 250, 20);
context.textAlign = &quot;start&quot;;
context.fillText(&quot;start&quot;, 250, 40);
context.textAlign = &quot;end&quot;;
context.fillText(&quot;end&quot;, 250, 60);
context.textAlign = &quot;left&quot;;
context.fillText(&quot;left&quot;, 250, 80);
context.textAlign = &quot;right&quot;;
context.fillText(&quot;right&quot;, 250, 100);</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-3-3">3.3.3 Drawing Images</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>Working with images is rather simple, except that we need the images to be 
fully loaded into memory before drawing them. Loading images is an 
<i>asynchronous</i> process we need to take care of. Working with multiple 
images might also be difficult for beginners. We present a multiple image loader 
later on in this course.</p>

<p><b>Let’s say it once again</b>: To use an image in a canvas, make sure that 
the image has been loaded by the Web browser before drawing it!</p>

<p>It is also possible to draw images from a video stream, images corresponding to 
another canvas content, or images that are defined by &lt;img&gt; HTML elements in 
the page. We will see that as well in the following parts of this chapter.</p>

<p>But let’s start with a basic example!</p>

<h4>Example #1: drawing an image in a canvas</h4>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Simple image drawing in a canvas&lt;/title&gt;
    &lt;script&gt;
      window.onload = function () {
      // Necessity to run this code only after the web page has been loaded.
      var canvas = document.getElementById(&quot;myCanvas&quot;);
      var context = canvas.getContext(&quot;2d&quot;);
      var imageObj = new Image();
      // Callback function called by the imageObj.src = .... line
      //located after this function
      imageObj.onload = function () {
      // Draw the image only when we have the guarantee
      // that it has been loaded
      context.drawImage(imageObj, 0, 0);
    };
    // Calls the imageObj.onload function asynchronously
    imageObj.src =
      &quot;https://www.w3.org/html/logo/downloads/HTML5_Logo_512.png&quot;;
    };
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Explanations:</h4>

<ol type="1">
  <li>We have to create a JavaScript Image object (<i>line 10</i>),</li>
  <li>When we set the src attribute of this object with the URL of the image file, 
    then an asynchronous request is sent in the background by the browser. Loading 
    a big image may take some time, so the rest of the Ja vaScript code continues 
    running. This is why we call it “asynchronous”.</li>
  <li>When the image file has been loaded, the browser calls the onload callback 
    associated with the image (<i>line 14</i>).</li>
  <li>We draw the image only from inside this callback, otherwise we have no 
    guarantee that the image has been loaded and can be usable. The actual 
    drawing here is done <i>line 1</i>.</li>
  <li>There are numerous variants of the drawImage(…) context method at <i>line 17</i></li>
</ol>

<ul>
  <li>drawImage(img, x, y): draws the image at position x, y, keeping the original 
    image size.</li>
  <li>drawImage(img, x, y, sizeX, sizeY): same as before except that the image 
    drawn is resized.</li>
  <li>drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh): for drawing sub-images, 
    (sx, sy, sw, sh) define the source rectangle, while dx, dy, dw, sh define 
    the target rectangle. If these rectangles don’t have the same size, the 
    source sub-image is resized.</li>
</ul>

<h4>See picture below:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 133. simple image drawing in a canvas (182) ~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image133.webp"
  loading="lazy"
  title="Drawing Images with Subimages. Source image within a Destination Canvas"
  alt="Drawing Images with Subimages. Source image within a Destination Canvas."
  style="width:45%;" />

<h4>Example #2: different variants of drawImage(…)</h4>

<p>This example illustrates the use of the different variants of the drawImage method:</p>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing images: drawImage variants&lt;/title&gt;
  &lt;script&gt;
    window.onload = function() {
    var canvas = document.getElementById(&quot;myCanvas&quot;);
    var context = canvas.getContext(&quot;2d&quot;);
    var imageObj = new Image();
    imageObj.onload = function() {
    // Try commenting/uncommenting the following lines to see the
    // effect of the different drawImage variants
    // Original, big image
    // context.drawImage(imageObj, 0, 10);
    // Original image drawn with size = 100x100 pixels
    context.drawImage(imageObj, 0, 10, 100, 100);
    // with size = 150x150
    context.drawImage(imageObj, 80, 10, 150, 150);
    // with size = 200x200
    context.drawImage(imageObj, 210, 10, 200, 200);
    // draw the sub image at 0, 0, width = 512, height = 100
    // at position 100, 250, with a width of 256 and a height of 50 
    context.drawImage(imageObj, 0, 0, 512, 100, 100, 250, 256, 50);
    };
    imageObj.src = &quot;https://www.w3.org/html/logo/downloads/HTML5_Logo_512.png&quot;;
    };
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>CSS source code:</h4>

<pre>#myCanvas {
  border:1px solid black;
}</pre>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var imageObj = new Image();
imageObj.onload = function() {
  // try commenting/uncommenting the following lines to see the
  // effect of the different drawImage variants
  // original, big image
  // context.drawImage(imageObj, 0, 10);
  // original image drawn with size = 100x100 pixels
  context.drawImage(imageObj, 0, 10, 100, 100);
  // with size = 150x150
  context.drawImage(imageObj, 80, 10, 150, 150);
  // with size = 200x200
  context.drawImage(imageObj, 210, 10, 200, 200);
  // draw the sub image at 0, 0, width = 512, height = 100
  // at position 100, 250, with a width of 256 and a height of 50
  context.drawImage(imageObj, 0, 0, 512, 100, 100, 250, 256, 50);
};
imageObj.src = &quot;https://www.w3.org/html/logo/downloads/HTML5_Logo_512.png&quot;;
};</pre>

</details>

<h4>Example #3: draw an image defined in the page by an &lt;img src="…"&gt; element</h4>

<p>Sometimes, you may want to draw an image that is already declared in the HTML 
document as an &lt;img src="..."&gt; element. Remember that when you add an &lt;img&gt; 
in the document, the browser starts downloading it in background.</p>

<h4>You could try drawing it using some code like this:</h4>

<pre>&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;
  &lt;p&gt;Original image as an &lt;img&gt; element:&lt;/p&gt;
  &lt;b&gt;&lt;img id=&quot;logo&quot;&lt;/b&gt;
  &lt;b&gt;src=&quot;https://fc07.deviantart.net/fs70/f/2013/149/b/8/texture_85_by_voyager168-d670m68.jpg&quot;&gt;&lt;/b&gt;
  &lt;script&gt;
    canvas = document.getElementById(&quot;myCanvas&quot;);
    var ctx = canvas.getContext(&quot;2d&quot;);
    var logo = document.querySelector(&quot;#logo&quot;);
    &lt;b&gt;ctx.drawImage(logo, 0, 0, 100, 100);&lt;/b&gt;
  &lt;/script&gt;
&lt;/body&gt;</pre>

<p>Although you will find many examples on the Web that do it this way, they will 
only work most of the time with small images, or with images that are in the browser’s 
cache. Remember that you cannot draw an image that has not been fully loaded!</p>

<p>If you try to draw an image that is not loaded or partially loaded, you will have 
unexpected results!</p>

<p><b>Best practice:</b> only draw an image that is fully loaded, use the onload 
callback! The right way to do this is shown in this online example, that starts 
drawing only from the onload callback function:</p>

<h4>CSS source code:</h4>

<pre>#myCanvas {
  border:1px solid black;
}</pre>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing an image with &lt;img&gt;&lt;/title&gt;
  &lt;script&gt;
    var canvas, context, imageObj;
    window.onload = function() {
    canvas = document.getElementById(&quot;myCanvas&quot;);
    context = canvas.getContext(&quot;2d&quot;);
    imageObj = document.querySelector(&quot;#logo&quot;);
    drawAllImages();
    };
    
    function drawAllImages() {
      console.log(&quot;image is already loaded, we draw it!&quot;);
      // Original image drawn with size = 100x100 pixels
      context.drawImage(imageObj, 0, 10, 100, 100);
      // with size = 150x150
      context.drawImage(imageObj, 80, 10, 150, 150);
      // with size = 200x200
      context.drawImage(imageObj, 210, 10, 200, 200);
      // draw the sub image at 0, 0, width = 512, height = 100
      // at position 100, 250, with a width of 256 and a height of 50
      context.drawImage(imageObj, 0, 0, 512, 100, 100, 250, 256, 50);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;A canvas with an image that is further in the page, loaded by the 
    &lt;img src=...&gt; tag. This is not the recommended way to load images, 
      except if the image is already in your page. Use the onload callback to be sure that the 
      image is in the page. &lt;/p&gt;
    &lt;canvas id=&quot;myCanvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;
    &lt;p&gt;Original image is an &amp;lt;img&gt; element:
  &lt;/p&gt;
  &lt;img id=&quot;logo&quot; src=&quot;https://www.w3.org/html/logo/downloads/HTML5_Logo_512.png&quot; 
    alt=&quot;html5 logo&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>With large image files, this will not break nor produce unexpected results:</p>

<h4>CSS source code:</h4>

<pre>#myCanvas {
  border:1px solid black;
}</pre>

<br/>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Using a large image&lt;/title&gt;
  &lt;script&gt;
    let canvas, context;
    window.onload = () =&gt; {
    canvas = document.getElementById(&quot;myCanvas&quot;);
    context = canvas.getContext(&quot;2d&quot;);
    draw();
    };

    function draw() {
      var imageObj = document.querySelector(&quot;#logo&quot;);
      console.log(&quot;Image has been loaded, let&#39;s draw it!&quot;);
      // Original image drawn with size = 100x100 pixels
      context.drawImage(imageObj, 0, 10, 100, 100);
      // with size = 150x150
      context.drawImage(imageObj, 80, 10, 150, 150);
      // with size = 200x200
      context.drawImage(imageObj, 210, 10, 200, 200);
      // draw the sub image at 0, 0, width = 512, height = 100
      // at position 100, 250, with a width of 256 and a height of 50
      context.drawImage(imageObj, 0, 0, 512, 100, 100, 250, 256, 50);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;It is possible that the drawing in the canvas below appears only after a few seconds, 
    because the image is very large!&lt;/p&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;512&quot; 
    height=&quot;512&quot;&gt;&lt;/canvas&gt;
  &lt;p&gt;Very large original image, declared as an &amp;lt;img&gt; element:
  &lt;/p&gt;
  &lt;img id=&quot;logo&quot; alt=&quot;logo&quot; src=&quot;https://mainline.i3s.unice.fr/mooc/texture_85_by_voyager168-d670m68.jpg&quot; 
    width=&quot;512&quot; height=&quot;512&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>The <a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents" 
target="_blank" rel="noopener noreferrer">DOM Level 2 Events specification</a> 
says: "<i>The load event occurs when the DOM implementation finishes loading all 
content within a document, all frames within a FRAMESET, or an OBJECT element.</i>"</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-3-4">3.3.4 Drawing Images from a Video Stream</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The drawImage(…) function can take a video element as its first parameter. 
The image that will be drawn is the one currently played by the video stream. 
This can be done at video frequency on most modern computers or mobile devices.</p>

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing images from a video stream&lt;/title&gt;
  &lt;style&gt;
    body {
      margin: 10px;
      padding: 0px;
    }
    #myCanvas {
      border: 10px solid red;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var video;
    var canvas, ctx;
    var angle = 0;
    
    function init() {
      video = document.getElementById(&#39;sourcevid&#39;);
      canvas = document.getElementById(&#39;myCanvas&#39;);
      ctx = canvas.getContext(&#39;2d&#39;);
      setInterval(&quot;processFrame()&quot;, 25);
    }
  
    function processFrame() {
      // Uncomment next line for drawing 100% copy of the video content
      //ctx.drawImage(video, 0, 0);
      // Comment these 4 lines if you uncommented the previous one
      ctx.drawImage(video, 0, 0, 320, 180);
      drawRotatingVideo(480, 90);
      ctx.drawImage(video, 0, 180, 320, 180);
      ctx.drawImage(video, 320, 180, 320, 180);
    }

    function drawRotatingVideo(x, y) {
      // Clear thze zone at the top right quarter of the canvas
      ctx.clearRect(320, 0, 320, 180);
      // We are going to change the coordinate system, save the context !
      ctx.save();
      // translate, rotate and recenter the image at its &quot;real&quot; center,
      //not the top left corner
      ctx.translate(x, y);
      ctx.rotate(angle += 0.01);
      ctx.translate(-80, -45);
      ctx.drawImage(video, 0, 0, 160, 90);
      // restore the context
      ctx.restore();
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init()&quot; &gt;
  &lt;p&gt;This is a &lt;code&gt;&amp;lt;video&gt;&lt;/code&gt; element: &lt;/p&gt;
  &lt;video id=&quot;sourcevid&quot; autoplay loop&gt;
  &lt;source src=&quot;https://mainline.i3s.unice.fr/mooc/BigBuckBunny_640x360.mp4&quot; 
    type=&quot;video/mp4&quot; /&gt;
  &lt;source src=&quot;https://mainline.i3s.unice.fr/mooc/BigBuckBunny_640x360.ogv&quot; 
    type=&quot;video/ogg&quot;/&gt;
  &lt;/video&gt;
  &lt;p&gt;This is a &lt;code&gt;&amp;lt;canvas&gt;&lt;/code&gt; element: &lt;/p&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;620&quot; height=&quot;360&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>This example shows:</p>

<ul>
  <li>a &lt;video&gt; element on top, and four images drawn in a canvas below.</li>
  <li>The images are drawn every XXX milliseconds using the setInterval(function, delay) method.</li>
</ul>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>&lt;script&gt;
  var video;
  var canvas, ctx;
  var angle = 0;
function init() {
  video = document.getElementById(&#39;sourcevid&#39;);
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  setInterval(&quot;processFrame()&quot;, 25); // call processFrame each 25ms
}
function processFrame() {
  ctx.drawImage(video, 0, 0, 320, 180);
  drawRotatingVideo(480, 90);
  ctx.drawImage(video, 0, 180, 320, 180);
  ctx.drawImage(video, 320, 180, 320, 180);
}
function drawRotatingVideo(x, y) {
  // Clear the zone at the top right quarter of the canvas
  ctx.clearRect(320, 0, 320, 180);
  // We are going to change the coordinate system, save the context!
  ctx.save();
  // translate, rotate and recenter the image at its &quot;real&quot; center,
  //not the top left corner
  ctx.translate(x, y);
  ctx.rotate(angle += 0.01); // rotate and increment the current angle
  ctx.translate(-80, -45);
  ctx.drawImage(video, 0, 0, 160, 90);
  // restore the context
  ctx.restore();
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init()&quot; &gt;
  &lt;p&gt;This is a &lt;video&gt;&lt;video&gt; element: &lt;/p&gt;
  &lt;video id=&quot;sourcevid&quot; autoplay=&quot;true&quot; loop=&quot;true&quot;&gt;
  &lt;source src=&quot;https://mainline.i3s.unice.fr/mooc/BigBuckBunny_640x360.mp4&quot;
         type=&quot;video/mp4&quot; /&gt;
  &lt;source src=&quot;https://mainline.i3s.unice.fr/mooc/BigBuckBunny_640x360.ogv&quot;
         type=&quot;video/ogg&quot;/&gt;
  &lt;/video&gt;
  &lt;p&gt;This is a &lt;canvas&gt; element: &lt;/p&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;620&quot; height=&quot;360&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;</pre>

</details>

<h4>Explanations:</h4>
<ul>
  <li><i>Line 11</i>: the call to setInterval will make the browser execute  the 
    processFrame function each 25ms.</li>
  <li><i>Lines 15, 17 and 18</i>: in processFrame, drawImage(…) is called 3 times 
    with the video element passed as first parameter.</li>
  <li><i>Line 43</i>: the video element declared at <i>line 43</i> has autoplay=true 
    and loop=true, it starts playing the video as soon as possible and will loop it.</li>
  <li><i>Line 21</i>: We implemented a rotating video effect in the drawRotatingVideo. 
    The use of context save/restore is primordial as this function changes the coordinate 
    system at each call, translating and rotating it. Notice the extra translation at 
    <i>line 31</i> that translates the coordinate system backwards with half of the 
    size of the image that is drawn. We did this in order to make the image rotate 
    around the center of the rectangle, instead of around the top left corner at 
    (0, 0) by default. Try commenting out this line in the running example and 
    you will see what we mean.</li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-1">3.4.1 Immediate Mode vs. Path Mode</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Immediate mode</h4>

<p>As a reminder: an immediate mode means “executing a call to a drawing
method means <i>immediately</i> drawing in the canvas”. The drawing
appears as soon as the design instruction is executed.</p>

<ul>
  <li>In the previous examples, we saw how to draw rectangles using the 
    fillRect(x, y, width, height) and strokeRect(x, y, width, height) 
    methods of the context.</li>
  <li>We also learned how to draw a text message using the 
    fillText(message, x, y) and strokeText(message, x, y) methods that 
    draws a text in filled and wireframe mode, respectively.</li>
</ul>

<ul>
  <li>These methods, along with the drawImage(…) method already seen in 
    section 3.3.3, are <i>"immediate methods"</i>: as soon as they are 
    executed, the results are displayed on screen, the drawings are 
    performed, pixels on the canvas area change their colors, etc.</li>
</ul>

<p>Here is an example that draws 1000 random rectangles in a canvas, using 
immediate mode rectangle drawing calls:</p>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas, ctx, w, h;
function init() {
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  w = canvas.width;
  h = canvas.height;
  console.time(&quot;time to draw&quot;);
  for(var i=0; i &lt; 1000; i++) {
    var x = Math.random() * w;
    var y = Math.random() * h;
    var width = Math.random() * w;
    var height = Math.random() * h;
    ctx.strokeRect(x, y, width, height);
  }
  console.timeEnd(&quot;time to draw&quot;);
}</pre>

</details>

<h4>HTML source code:</h4>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Canvas&lt;/title&gt;
&lt;/head&gt;
&lt;body onload = init();&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height =400&gt;
    Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<br/>

<details>
  <summary><b>CSS source code:</b></summary>

<pre>var canvas, ctx, w, h;
function init() {
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  w = canvas.width;
  h = canvas.height;
  console.time(&quot;time to draw&quot;);
  for(var i=0; i &lt; 1000; i++) {
    var x = Math.random() * w;
    var y = Math.random() * h;
    var width = Math.random() * w;
    var height = Math.random() * h;
    ctx.strokeRect(x, y, width, height);
  }
  console.timeEnd(&quot;time to draw&quot;);
}</pre>

</details>

<p><i>Lines 12-18</i> draw 1000 rectangles of random sizes in immediate mode. 
We also measure the time using the usual console.time(name_of_timer) and 
console.timeEnd(name_of_timer) that will write in the browser console the 
time elapsed. Note that console.time(…) and console.timeEnd(…) display 
results only in the
browser’s console, not in the JSBin console.</p>
<p>On a Mac Book Pro from 2015, the result is an average time of 4.034ms 
for drawing all these rectangles:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~ 134. image of the devtool console clocking time to draw rectangles (189) ~~~~~~~~-->
<img class="displayed"
  src="./images/image134.webp"
  loading="lazy"
  title="Image of the devtool console measuring average time to draw rectangles"
  alt="Image of the devtool console measuring average time to draw rectangles."
  style="width:40%;" />

<h4>Path mode</h4>

<p>There is another drawing mode called “path drawing mode” where you
first send drawing orders to the graphics processor, and these orders
are stored in a buffer. Then you call methods to draw the whole buffer
at once. There are also methods to erase the buffer’s content.</p>
<p>Path drawing mode allows parallelism: if you need to draw 10,000
rectangles, it’s better to store the orders in the graphics card, then
execute the drawing all at once, rather than doing 10,000 immediate
calls to strokeRect(…) for example. With the buffered mode, the Graphic
Processing Unit (GPU) of the graphics card hardware will be able to
parallelize the computations (modern graphics cards can execute
hundreds/thousands of things in parallel).</p>
<p>Same example as before, this time using the buffered mode for drawing
rectangles:</p>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, w, h;
function init() {
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  w = canvas.width;
  h = canvas.height;
  console.time(&quot;time to draw&quot;);
  for(var i=0; i &lt; 1000; i++) {
    var x = Math.random() * w;
    var y = Math.random() * h;
    var width = Math.random() * w;
    var height = Math.random() * h;
    ctx.rect(x, y, width, height);
  }
  ctx.stroke();
  console.timeEnd(&quot;time to draw&quot;);
}</pre>

</details>

<h4>HTML source code:</h4>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Canvas&lt;/title&gt;
&lt;/head&gt;
&lt;body onload = init();&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height =400&gt;
    Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Extract from source code (the part that draws the rectangles):</p>

<pre>for(var i=0; i &lt; 1000; i++) {
  var x = Math.random() * w;
  var y = Math.random() * h;
  var width = Math.random() * w;
  var height = Math.random() * h;
  ctx.rect(x, y, width, height); // store a rectangle in path/buffer
}
ctx.stroke(); // draws the whole buffer (the 1000 rectangles) at once
</pre>
<p>Instead of calling strokeRect(…) or fillRect(…), we just call
the rect(…) method of the context (<i>line 7</i>). This is how we can
delay the drawing of the rectangles. The 1000 rectangles are stored in a
buffer in the hardware.</p>
<p>The call to ctx.stroke() (<i>line 9</i>) or to its sister
method ctx.fill() will draw the entire buffer contents in fill or stroke
mode.</p>
<p>And here is what the timer gives: a slightly faster execution time.
Changing 1000 to 100,000 will give even larger differences.</p>
<p><b>Path mode is faster than immediate mode! We have now an average
time of 3.1ms</b></p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~ 135. image of the devtool console which shows time path vs immediate (191) ~~~~~~~~-->
<img class="displayed"
  src="./images/image135.webp"
  loading="lazy"
  title="Image of the devtool console which shows time values, path vs immediate mode"
  alt="Image of the devtool console which shows time values, path vs immediate mode."
  style="width:40%;" />

<h4>Reset the path mode buffer</h4>

<p>A call to ctx.beginPath() will reset the buffer (empty its contents).
We will see many more examples of using the path drawing mode in another
further section.</p>

<pre>// start a new buffer / path
ctx.beginPath();
// all these orders are in a buffer/path
ctx.moveTo(10, 10);
ctx.lineTo(100, 100);
ctx.lineTo(150, 70);
// Draw the buffer
ctx.stroke();</pre>

<p>Summary of path mode principles</p>

<ol type="1">
  <li>Call drawing methods that work in path mode, for example call ctx.rect(…) instead 
    of ctx.strokeRect(…) or ctx.fillRect(…),</li>
  <li>Call ctx.stroke() or ctx.fill() to draw the buffer’s contents,</li>
  <li>Beware that the buffer is never emptied, two consecutive calls to ctx.stroke() 
    will draw the buffer contents twice! Instead, use ctx.beginPath() to empty it if needed,</li>
  <li>It is possible to empty the buffer by calling ctx.beginPath(),</li>
  <li>Path drawing is faster than immediate drawing (parallelization is possible).</li>
</ol>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-2">3.4.2 A Warning</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p><b>Warning</b>: you do not need to spend too much time on each part of this 
sub-section.</p>
<p>You do not need to memorize or learn by heart all the examples in the following 
pages. They are given as references. There will be no quizzes about curves as they 
are not often done “by hand”, but are generated by tools such as Adobe Illustrator 
or online generators.</p>

<ul>
  <li>You need to draw arcs? Then, please use the corresponding section as a reference: 
    you know you will find one or more examples and a detailed explanation.</li>
  <li>You need to draw lines? Arrows? Curves? Same thing: go to the corresponding 
    pages and look at the examples!</li>
</ul>

<p>Also, do not forget to use your favorite HTML5 canvas cheatsheet
(provided before in the last section). You will find it very
helpful when you start playing with the canvas.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-3">3.4.3 Drawing Lines</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>We have been drawing rectangles so far.</p>

<p>Now let’s go a bit further by introducing the notion of “path drawing”. This approach 
uses the ctx.moveTo(x, y) method of the context, in conjunction with other drawing methods 
that end in “To”, such as ctx.lineTo(x, y).</p>

<p>This makes it easier to draw multiple connected lines. Consecutive calls to ctx.lineTo(x, y) 
will store in the path/buffer a set of connected lines that we will draw altogether by a single 
call to ctx.stroke() or ctx.fill().</p>

<h4>Here are the 5 different steps:</h4>

<ol type="1">
  <li>Put the “pencil” somewhere with a call to ctx.moveTo(x1, y1). This will be the origin 
    of the first line.</li>
  <li>Call the ctx.lineTo(x2, y2) method to draw a line from the previous position 
    (previous step) to the position passed as parameters to the lineTo(…) method. 
    This position will serve as the origin for the next line to be drawn.</li>
  <li>Call lineTo(x3, y3) again to draw a line that goes from (x2, y2) to (x3, y3). 
    This line will start at the end of the previous one.</li>
  <li>Repeat step 3 to draw more connected lines.</li>
  <li>Call the ctx.stroke() or the ctx.fill() methods to draw the path defined by the 
    different lines.</li>
</ol>

<p>Note the call to ctx.stroke() or ctx.fill() will use the current values of the strokeStyle 
or fillStyle properties. It is possible to call ctx.moveTo(x, y) in the middle of steps 1 
through 5 in order to move the pen somewhere else without connecting to the last drawn line.</p>

<h4>Drawing a grid</h4>

<h4>See the example below:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 136. draw grid using ctx.stroke (193) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image136.webp"
  loading="lazy"
  title="Draw blue grid using ctx.stroke command"
  alt="Draw blue grid using ctx.stroke command."
  style="width:40%;" />

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing a grid&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var ctx=canvas.getContext(&#39;2d&#39;);
    // Vertical lines
    for (var x = 0.5; x &lt; 500; x += 10) {
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 375);
    }
    // Horizontal lines
    for (var y = 0.5; y &lt; 375; y += 10) {
      ctx.moveTo(0, y);
      ctx.lineTo(500, y);
    }
    // Draw in blue
    ctx.strokeStyle = &quot;#0000FF&quot;;
    // Before the execution of the next line nothing as been drawn yet !
    ctx.stroke();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// Vertical lines
for (var x = 0.5; x &lt; 500; x += 10) {
  ctx.moveTo(x, 0);
  ctx.lineTo(x, 375);
}
// Horizontal lines
for (var y = 0.5; y &lt; 375; y += 10) {
  ctx.moveTo(0, y);
  ctx.lineTo(500, y);
}
// Draw in blue
ctx.strokeStyle = &quot;#0000FF&quot;;
// Until the execution of the next line, nothing has been drawn!
ctx.stroke();</pre>

</details>

<p>In this example, the entire grid is drawn during the execution of the last line 
of code, with the single call to ctx.stroke().</p>

<h4>Mixing filled and wireframe shapes (and immediate and path modes)</h4>

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~ 137. mix filled & wireframe shapes using different methods (194) ~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image137.webp"
  loading="lazy"
  title="Mix filled and wireframe shapes using different methods"
  alt="Mix filled and wireframe shapes using different methods."
  style="width:40%;" />

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Canvas&lt;/title&gt;
&lt;/head&gt;
&lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var canvas=document.getElementById(&#39;myCanvas&#39;);
  var ctx=canvas.getContext(&#39;2d&#39;);
  ctx.fillStyle=&#39;#FF0000&#39;;
  ctx.fillRect(0,0,80,100);
  ctx.moveTo(0,0);
  ctx.lineTo(100, 100);
  ctx.lineTo(100,0);
  ctx.strokeStyle = &quot;#0000FF&quot;;
  ctx.stroke();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// a filled rectangle in immediate mode
ctx.fillStyle=&#39;#FF0000&#39;;
ctx.fillRect(0,0,80,100);
// two consecutive lines in path mode
ctx.moveTo(0,0);
ctx.lineTo(100, 100);
ctx.lineTo(100,0);
// draws only the two lines in wireframe mode
ctx.strokeStyle = &quot;#0000FF&quot;;
ctx.stroke();</pre>

</details>

<p>This example shows that filled and wireframe shapes should be drawn differently 
(here a filled rectangle is drawn using a call to the fillRect(…) method while a 
wireframe set of connected lines is drawn using the stroke() method of the context).</p>

<h4>Drawing a single path made with disconnected lines / parts</h4>

<p>Try this:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~ 138. drawing single path made with disconnected lines (195) ~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image138.webp"
  loading="lazy"
  title="Drawing single path made with disconnected lines"
  alt="Drawing single path made with disconnected lines."
  style="width:40%;" />

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// first part of the path
ctx.moveTo(20,20);
ctx.lineTo(100, 100);
ctx.lineTo(100,0);
// second part of the path, moveTo(...) is used to &quot;jump&quot; to another place
ctx.moveTo(120,20);
ctx.lineTo(200, 100);
ctx.lineTo(200,0);
// indicate stroke color + draw the path
ctx.strokeStyle = &quot;#0000FF&quot;;
ctx.stroke();</pre>

</details>

<p>In this last example, we simply called the moveTo() method between
each part of the path (<i>lines 5 and 10</i>). And we
called stroke() (<i>line 16</i>) only once to draw the whole path.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-4">3.4.4 Drawing Lines with Different Styles</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Common mistake: drawing the same path twice</h4>
<p>Let’s look at the drawing from the last example of the previous section:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~ 139. example using moveto() and stroke() command functions (196) ~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image139.webp"
  loading="lazy"
  title="Same drawing as in previous section. Example using moveto() and stroke() command functions"
  alt="Same drawing as in previous section. Example using moveto() and stroke() command functions."
  style="width:40%;" />

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing disconnected lines&lt;/title&gt;
&lt;/head&gt;
&lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var canvas=document.getElementById(&#39;myCanvas&#39;);
  var ctx=canvas.getContext(&#39;2d&#39;);
  // first part of the path
  ctx.moveTo(20,20);
  ctx.lineTo(100, 100);
  ctx.lineTo(100,0);
  // second part of the path, moveTo(...) is used to &quot;jump&quot; to another place
  ctx.moveTo(120,20);
  ctx.lineTo(200, 100);
  ctx.lineTo(200,0);
  // indicate stroke color + draw the path
  ctx.strokeStyle = &quot;#0000FF&quot;;
  ctx.stroke();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>Imagine that we would like to draw them with different styles and
colors: the shape on the left will stay as it is now (blue, wireframe),
while the shape on the right will be filled, colored in pink. Let’s look
at how we can do this…</p>
<h4>Drawing two paths with different styles: the WRONG and the right way!</h4>
<h4>First, the <em>wrong</em> way!</h4>
<p>In this example, we will draw the two parts of the path with
different styles: the first part in wireframe mode, and the second part
in filled mode.</p>
<p>What we will try first is to call stroke() after the first half of
the path, then call fill() after the second half of the path:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~ 140. the wrong way to draw two paths with different styles (197) ~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image140.webp"
  loading="lazy"
  title="THE WRONG WAY! Drawing two paths with different styles"
  alt="THE WRONG WAY! Drawing two paths with different styles."
  style="width:40%;" />

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing two paths with different styles: the wrong way!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var canvas=document.getElementById(&#39;myCanvas&#39;);
  var ctx=canvas.getContext(&#39;2d&#39;);
  // first part of the path
  ctx.moveTo(20,20);
  ctx.lineTo(100, 100);
  ctx.lineTo(100,0);
  // indicate stroke color + draw first part of the path
  ctx.strokeStyle = &quot;#0000FF&quot;;
  ctx.stroke();
  // second part of the path
  ctx.moveTo(120,20);
  ctx.lineTo(200, 100);
  ctx.lineTo(200,0);
  // indicate stroke color + draw the path
  ctx.fillStyle = &quot;pink&quot;;
  ctx.fill();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// first part of the path
ctx.moveTo(20,20);
ctx.lineTo(100, 100);
ctx.lineTo(100,0);
// indicate stroke color + draw first part of the path
ctx.strokeStyle = &quot;#0000FF&quot;;
ctx.stroke();
// second part of the path
ctx.moveTo(120,20);
ctx.lineTo(200, 100);
ctx.lineTo(200,0);
// indicate stroke color + draw the path
ctx.fillStyle = &quot;pink&quot;;
ctx.fill();</pre>

</details>

<p>Hey - it does not work! Weirdly, the two parts of the path are filled
in pink! But we called stroke() after the first half of the path was
drawn (<i>lines 5-8</i>). Then we called fill() only after the second
part of the path was specified (<i>lines 14-19</i>)… so, what
happened?</p>
<p>Remember that fill() or stroke() <i>draws the whole path</i>, even if
it is disconnected, and even if it has already been drawn!</p>
<p>What happened is:</p>

<ol type="1">
  <li>The call to stroke() has drawn the path corresponding to the <i>lines 5-7</i>. 
    Indeed, the first part of the path (on the left) has actually been drawn once in 
    wireframe mode, and in blue.</li>
  <li>Then, the call to fill() at <i>line 20</i> has drawn the whole path again, but 
    in pink and in filled mode. But this time the path corresponds to <i>lines 5-7</i> 
    plus <i>lines 14-16</i> that make up the second shape on the right. <i>So the path 
    that has been drawn this time is made of both of the triangles.</i></li>
</ol>

<p><b>Important</b>: If you do not want to draw parts of the same path
several times, you need to draw two different paths, using
the ctx.beginPath() method, as shown in the next example.</p>

<h4>Now, the <em>right</em> way!</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~ 141. the right way to draw two paths with different styles (198) ~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image141.webp"
  loading="lazy"
  title="Draw two paths with different styles the RIGHT way"
  alt="Draw two paths with different styles the RIGHT way."
  style="width:40%;" />

<details>
  <summary><b>HTML source code:</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing two paths with different styles: the right way!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var canvas=document.getElementById(&#39;myCanvas&#39;);
  var ctx=canvas.getContext(&#39;2d&#39;);
  // first part of the path
  ctx.moveTo(20,20);
  ctx.lineTo(100, 100);
  ctx.lineTo(100,0);
  // indicate stroke color + draw first part of the path
  ctx.strokeStyle = &quot;#0000FF&quot;;
  ctx.stroke();
  // start a new path, empty the current buffer
  ctx.beginPath();
  // second part of the path
  ctx.moveTo(120,20);
  ctx.lineTo(200, 100);
  ctx.lineTo(200,0);
  // indicate stroke color + draw the path
  ctx.fillStyle = &quot;pink&quot;;
  ctx.fill();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<br/>

<details>
  <summary><b>JavaScript source code:</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// first part of the path
ctx.moveTo(20,20);
ctx.lineTo(100, 100);
ctx.lineTo(100,0);
// indicate stroke color + draw first part of the path
ctx.strokeStyle = &quot;#0000FF&quot;;
ctx.stroke();
// start a new path, empty the current buffer
ctx.beginPath();
// second part of the path
ctx.moveTo(120,20);
ctx.lineTo(200, 100);
ctx.lineTo(200,0);
// indicate stroke color + draw the path
ctx.fillStyle = &quot;pink&quot;;
ctx.fill();</pre>

</details>

<p>This time, in order to draw the two shapes differently, we defined
two separate paths. The way to do this is just to
call ctx.beginPath() to start a new path. In this example, the first
path has been drawn in wireframe mode, then a new path has been started
that is drawn in filled mode.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-5">3.4.5 Drawing Lines in Immediate Mode</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>Sometimes, it might be useful to draw just one line.</p>
<p>It’s interesting to see how we can write a single “draw line”
function that takes the start and end coordinates, the color, the line
width, etc., and give the impression of being done in “immediate”
mode.</p>

<h4>Here is the code for this “utility” function that you may find useful:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function drawLine(x1, y1, x2, y2, color, width) {
  ctx.save();
  // set color and lineWidth, if these parameters
  // are not defined, do nothing (default values)
  if(color)
    ctx.strokeStyle = color;
  if(width)
    ctx.lineWidth = width;
  // start a new path
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<p>Notice the save/restore of the context at the beginning/end of the
function. This is REALLY a best practice to avoid affecting other
functions’ context.</p>

<ul>
  <li><i>Line 13</i> starts a new path so that the function will only draw what it is meant to draw: a single line.</li>
  <li><i>Lines 15-17</i> move the “pen” at (x1, y1) then draw a line to (x2, y2), and the stroke at <i>line 17</i> makes it appear on the screen.</li>
</ul>

<h4>Here is an example:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 142. drawing lines in immediate mode (200) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image142.webp"
  loading="lazy"
  title="Drawing lines in immediate mode to avoid affecting other functions' context"
  alt="Drawing lines in immediate mode to avoid affecting other functions' context."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Drawing lines in immediate mode&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
  var canvas=document.getElementById(&#39;myCanvas&#39;);
  var ctx=canvas.getContext(&#39;2d&#39;);
  drawLine(0, 0, 100, 100);
  drawLine(0, 50, 150, 200, &#39;red&#39;);
  drawLine(10, 100, 100, 10, &#39;green&#39;, 10);
  function drawLine(x1, y1, x2, y2, color, width) {
    ctx.save();
    // set color and lineWidth, if these parameters
    // are not defined, do nothing (default values)
    if(color)
      ctx.strokeStyle = color;
    if(width)
      ctx.lineWidth = width;
    // start a new path
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Source code extract:</h4>

<pre>drawLine(0, 0, 100, 100);
drawLine(0, 50, 150, 200, &#39;red&#39;);
drawLine(10, 100, 100, 10, &#39;green&#39;, 10);</pre>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-6">3.4.6 Drawing Arrows</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>In this section, we present a function that draws arrows in a
canvas.</p>

<p>You may find multiple implementations on the Web for drawing arrows
in a canvas, but the one we are presenting has the advantage of being
rather simple and enables you to set the color and line width of the
arrows.</p>

<h3>Examples</h3>

<h4>Example #1:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>// Adapted from : https://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
  //variables to be used when creating the arrow
  var headlen = 10;
  var angle = Math.atan2(toy-fromy,tox-fromx);
  ctx.save();
  ctx.strokeStyle = color;
  //starting path of the arrow from the start square to the end square
  //and drawing the stroke
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineWidth = arrowWidth;
  ctx.stroke();
  //starting a new path from the head of the arrow to one of the sides of
  //the point
  ctx.beginPath();
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),
    toy-headlen*Math.sin(angle-Math.PI/7));
  //path from the side point of the arrow, to the other side point
  ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),
    toy-headlen*Math.sin(angle+Math.PI/7));
  //path from the side point back to the tip of the arrow, and then
  //again to the opposite side point
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),
    toy-headlen*Math.sin(angle-Math.PI/7));
  //draws the paths created above
  ctx.stroke();
  ctx.restore();
}</pre>

</details>

<h4>Explanations:</h4>

<ul>
  <li>An arrow is made of one line (the arrow body) and three connected lines (the arrow head).</li>
  <li>As we modify some context properties in this function, we call save() and restore() at the beginning and at the end of the function.</li>
  <li>This function can be improved in many ways: adding shadows, using fill() instead of stroke(), which gives strange results when the width is too big, etc.</li>
</ul>

<h4>Example #2</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 143. draw arrows (202) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image143.webp"
  loading="lazy"
  title="Function to draw arrows"
  alt="Function to draw arrows."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing arrows&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var ctx=canvas.getContext(&#39;2d&#39;);
    // Adapted from : http://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
    function drawArrow(ctx, fromx, fromy, tox, toy, arrowWidth, color){
      //variables to be used when creating the arrow
      var headlen = 10;
      var angle = Math.atan2(toy-fromy,tox-fromx);
      ctx.save();
      ctx.strokeStyle = color;
      //starting path of the arrow from the start square to the end square
      //and drawing the stroke
      ctx.beginPath();
      ctx.moveTo(fromx, fromy);
      ctx.lineTo(tox, toy);
      ctx.lineWidth = arrowWidth;
      ctx.stroke();
      //starting a new path from the head of the arrow to one of the sides of
      //the point
      ctx.beginPath();
      ctx.moveTo(tox, toy);
      ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),
      toy-headlen*Math.sin(angle-Math.PI/7));
      //path from the side point of the arrow, to the other side point
      ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),
      toy-headlen*Math.sin(angle+Math.PI/7));
      //path from the side point back to the tip of the arrow, and then
      //again to the opposite side point
      ctx.lineTo(tox, toy);
      ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),
      toy-headlen*Math.sin(angle-Math.PI/7));
      //draws the paths created above
      ctx.stroke();
      ctx.restore();
    }
    drawArrow(ctx, 10, 10, 100, 100, 10, &#39;red&#39;);
    drawArrow(ctx, 100, 10, 140, 140, 3, &#39;black&#39;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Source code extract:</h4>

<pre>drawArrow(ctx, 10, 10, 100, 100, 10, &#39;red&#39;);
drawArrow(ctx, 100, 10, 140, 140, 3, &#39;black&#39;);</pre>

<h4>How to draw nicer arrows?</h4>

<p>On the Web, you will find many different ways to draw arrows.</p>

<p>This <a href="http://www.dbp-consulting.com/tutorials/canvas/CanvasArrow.html" 
target="_blank" rel="noopener noreferrer">article on drawing lines and arcs with 
arrow heads</a> is worth reading. It details how to draw arrows with curved heads 
and different styles for the head. Note, however, that you will need to modify 
some parts if you want it to support different line widths, etc.</p>

<p>Screenshot from a demo available on the above Web site:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~ 144. clock with nicer arrows (204) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image144.webp"
  loading="lazy"
  title="Round clock with nice arrows"
  alt="Round clock with nice arrows."
  style="width:20%;" />

<p>In a later part of the course dedicated to curve drawing in a canvas,
we will also show how to draw curved arrows, with very simple code (much
simpler than the one used for drawing the clock’s hands above).</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-7">3.4.7 Closing a Path</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The ctx.closePath() method indicates that we would like a closed
path: draw from the last point to the first.</p>

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 145. example closing a path (204) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image145.webp"
  loading="lazy"
  title="Example on closing a path in a drawing"
  alt="Example on closing a path in a drawing."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Closing a path&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var ctx=canvas.getContext(&#39;2d&#39;);
    // Path made of three points (defines two lines)
    ctx.moveTo(20,20);
    ctx.lineTo(100, 100);
    ctx.lineTo(100,0);
    // Close the path, try commenting this line
    ctx.closePath();
    // indicate stroke color + draw first part of the path
    ctx.strokeStyle = &quot;blue&quot;;
    ctx.stroke();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas=document.getElementById(&#39;myCanvas&#39;);
var ctx=canvas.getContext(&#39;2d&#39;);
// Path made of three points (defines two lines)
ctx.moveTo(20,20);
ctx.lineTo(100, 100);
ctx.lineTo(100,0);
// Close the path, try commenting this line
ctx.closePath();
// indicate stroke color + draw first part of the path
ctx.strokeStyle = &quot;blue&quot;;
ctx.stroke();</pre>

</details>

<h4>Explanations:</h4>

<ul>
  <li><i>Lines 5-7</i> corresponds to a path made of two consecutive lines. If we 
    just call stroke() after that, two lines will be drawn on the canvas.</li>
  <li><i>Line 10</i> indicates that we would like <i>a closed path</i>.  In this 
    case, the call to stroke() at <i>line 14</i> will draw the two lines plus an 
    extra line that connects the last point of the path to the first one. It will 
    draw a closed triangle!</li>
</ul>

<p>Try commenting the <i>line 10</i> in the online example and see the results!</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-8">3.4.8 Drawing Circles and Arcs</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>The ctx.arc(cx, cy, radius, startAngle, endAngle, drawInverse) method is useful 
for drawing arcs of circles. It takes the center of the circle/arc, its radius, the 
starting angle of the arc (turning clockwise), the ending angle of the arc, and an 
optional parameter we will talk about later.</p>

<p><i>Note</i>: the figures in this page have been borrowed from the 
<a href="https://www.html5canvastutorials.com/tutorials/html5-canvas-arcs/" 
target="_blank" rel="noopener noreferrer">HTML5 Canvas Tutorials</a> Web site.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~ 146. html5 canvas arc diagram: drawing circle coordinate system (205) ~~~~~~~~~~-->
<img class="displayed"
  src="./images/image146.webp"
  loading="lazy"
  title="HTML5 canvas arc diagram: drawing circle, coordinate system"
  alt="HTML5 canvas arc diagram: drawing circle, coordinate system."
  style="width:40%;" />

<h4>Typical usage</h4>

<h4>Typical usage for drawing an arc/circle/ellipse is:</h4>

<pre>ctx.arc(centerX, centerY, radius, startAngle, endAngle); // clockwise drawing
ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);</pre>

<p>The angles are in radians (between 0 and 2*Math.PI). The arc is drawn
clockwise. Beware that this may not seem natural if you’re used to the
trigonometric order.</p>
<p>The last parameter is optional and has a value of false by default.
If true, instead of drawing an arc of circle that corresponds to the
parameters, <i>it will draw its complementary</i>. See the examples
below to see the difference.</p>

<h3>Examples</h3>

<h4>Example #1: drawing an arc with radius = 50, starting angle = 0, end angle = PI/2</h4>

<h4>Try this example:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~ 147. example drawing an arc with radius = 50 (206) ~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image147.webp"
  loading="lazy"
  title="Example on drawing an arc with radius = 50, start angle = 0, end angle = pi/2"
  alt="Example on drawing an arc with radius = 50, start angle = 0, end angle = pi/2."
  style="width:40%;" />

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Drawing an arc&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var ctx=canvas.getContext(&#39;2d&#39;);
    ctx.beginPath();
    // try to set the last parameter to true or remove it
    ctx.arc(100,75,50,0,Math.PI/2);
    ctx.lineWidth=10;
    ctx.stroke();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>JavaScript source code extract:</h4>

<pre>ctx.beginPath();
// we ommited the last parameter
ctx.arc(100, 75, 50, 0, Math.PI/2);
ctx.lineWidth = 10;
ctx.stroke();</pre>

<p>And if we change the last parameter of the arc function call (<i>line
3</i>) to true (we omitted it, so it took a value of false by default)
:</p>

<pre>ctx.beginPath();
// we omitted the last parameter
ctx.arc(100, 75, 50, 0, Math.PI/2, true);
ctx.lineWidth = 10;
ctx.stroke();</pre>

<p>Then, the result is the “complementary” of the previous arc:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~ 148. example arc complementary of the previous arc (207) ~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image148.webp"
  loading="lazy"
  title="Example complementary of the previous arc"
  alt="Example complementary of the previous arc."
  style="width:40%;" />
   
<h4>Example #2: drawing a Full circle (filled + outlined)</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 149. example draw a full circle (207) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image149.webp"
  loading="lazy"
  title="Example draw a full circle"
  alt="Example draw a full circle."
  style="width:40%;" />

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas = document.getElementById(&quot;myCanvas&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
var centerX = canvas.width / 2;
var centerY = canvas.height / 2;
var radius = 70;
ctx.beginPath();
// Add to the path a full circle (from 0 to 2PI)
ctx.arc(centerX, centerY, radius, 0, 2*Math.PI, false);
// With path drawing you can change the context
// properties until a call to stroke() or fill() is performed
ctx.fillStyle = &quot;lightBlue&quot;;
// Draws the filled circle in light blue
ctx.fill();
// Prepare for the outline
ctx.lineWidth = 5;
ctx.strokeStyle = &quot;black&quot;;
// draws the path (the circle) AGAIN, this
// time in wireframe
ctx.stroke();
// Notice we called ctx.arc() only once ! And drew it twice
// with different styles</pre>

</details>

<p>Notice that we called ctx.arc() only once! And drew it twice, with
different styles, with calls to ctx.stroke() and ctx.fill(). Each call
drew the defined path in wireframe and in filled mode!</p>

<h4>Proposed projects</h4>

<h4>Project #1: modify the <a href="https://codepen.io/w3devcampus/pen/YzZBxmO" 
target="_blank" rel="noopener noreferrer">previous example</a> in order to get:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 150. half circle (208) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image150.webp"
  loading="lazy"
  title="Example of half circle"
  alt="Example of half circle."
  style="width:25%;" />

<h4>Project #2: make a small program that draws a smiling head like this (or make something better!)</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 151. smiley face (208) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image151.webp"
  loading="lazy"
  title="Example of smiling head"
  alt="Example of smiling head."
  style="width:30%;" />
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-9">3.4.9 Drawing Rounded Rectangles</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>There is another method called ctx.arcTo(x1, y1, x2, y2,
radius), which is a bit complex to use, but very practical for drawing
rounded rectangles.</p>
<p>In fact, the arcTo(…) method draws an arc of a circle depending on
some tangents. Let’s look at these pictures for a better
understanding:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~ 152. three diagrams to explain arcto method (209) ~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image152.webp"
  loading="lazy"
  title="There are three (3) diagrams, all drawn on canvas dynamically. The arcTo really uses carTo() with reduced alpha, and the rest of the diagram is calculated in JavaScript and drawn with lineTo and arc"
  alt="There are three (3) diagrams, all drawn on canvas dynamically. The arcTo really uses carTo() with reduced alpha, and the rest of the diagram is calculated in JavaScript and drawn with lineTo and arc."
  style="width:40%;" />
  
<h4>Typical use:</h4>

<pre>ctx.moveTo(x0, y0);
ctx.arcTo(x1, y1, x2, y2, radius);</pre>

<p>This method can be confusing. It was defined mainly for drawing
rounded shapes like rounded rectangles. We used an excerpt here from the
excellent <a
href="http://www.dbp-consulting.com/tutorials/canvas/CanvasArcTo.html" target="_blank" rel="noopener noreferrer">tutorial on the arcTo(…) method</a>.</p>

<h4>It works like this:</h4>

<pre>Draw an imaginary line through (x0,y0) and (x1,y1), draw another imaginary line through (x1,y1) and (x2,y2),
Take an imaginary circle of radius r, and slide it up between the two lines until it just touches both lines. The two points at which the circle touches the lines are called the tangent points.
arcTo(x1, y1, x2, y2, r) will draw a line from the current point (x0,y0) to the first tangent point on the line from (x0,y0) to (x1,y1),
It will also draw an arc from that tangent point to the other tangent point on the line from (x1,y1) to (x2,y2) along the circumference of the circle.
Finally, it adds the tangent point where the arc ends up, on the line from (x1,y1) to (x2,y2) to the path as the new current point on the path.</pre>

<h4>Examples</h4>

<h4>Example #1: simple use</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~ 153. simple use arcto example 1 (209) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image153.webp"
  loading="lazy"
  title="Simple use arcTo example #1"
  alt="Simple use arcTo example #1."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Simple use - arcTo - Example #1&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot; height = 400 width=&quot;800&quot;&gt;Your browser does not 
      support the canvas tag.&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      var canvas=document.getElementById(&#39;myCanvas&#39;);
      var context=canvas.getContext(&#39;2d&#39;);
      context.beginPath();
      context.moveTo(0, 20);
      context.arcTo(100, 100, 200, 20, 50);
      context.lineWidth = 5;
      context.strokeStyle = &quot;#0000ff&quot;;
      context.stroke();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>JavaScript source code extract:</h4>

<pre>context.beginPath();
context.moveTo(0, 20);
context.arcTo(100, 100, 200, 20, 50);
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
context.stroke();</pre>

<h4>Example #2: draw A rounded rectangle</h4>

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 154. rounded rectange example 2 (210) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image154.webp"
  loading="lazy"
  title="Draw a rounded rectange, example #2"
  alt="Draw a rounded rectange, example #2."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Canvas&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var roundedRect=function(ctx,x,y,width,height,radius,fill,stroke)
    {
      ctx.beginPath();
      // draw top and top right corner
      ctx.moveTo(x+radius,y);
      ctx.arcTo(x+width,y,x+width,y+radius,radius);
      // draw right side and bottom right corner
      ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius);
      // draw bottom and bottom left corner
      ctx.arcTo(x,y+height,x,y+height-radius,radius);
      // draw left and top left corner
      ctx.arcTo(x,y,x+radius,y,radius);
      if(fill){
        ctx.fill();
      }
      if(stroke){
        ctx.stroke();
        }
    }
    var canvas=document.getElementById(&#39;myCanvas&#39;);
    var ctx=canvas.getContext(&#39;2d&#39;);
    ctx.strokeStyle=&#39;rgb(150,0,0)&#39;;
    ctx.fillStyle=&#39;rgb(0,150,0)&#39;;
    ctx.lineWidth=7;
    roundedRect(ctx,15,15,160,120,20,true,true);
  &lt;/script&gt;
&lt;/body&gt;</pre>

</details>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre> var roundedRect=function(ctx,x,y,width,height,radius,fill,stroke) {
  ctx.beginPath();
  // draw top and top right corner
  ctx.moveTo(x+radius,y);
  ctx.arcTo(x+width,y,x+width,y+radius,radius);
  // draw right side and bottom right corner
  ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius);
  // draw bottom and bottom left corner
  ctx.arcTo(x,y+height,x,y+height-radius,radius);
  // draw left and top left corner
  ctx.arcTo(x,y,x+radius,y,radius);
  if(fill) {
    ctx.fill();
  }
  if(stroke){
    ctx.stroke();
  }
}
var canvas = document.getElementById(&#39;myCanvas&#39;);
var ctx    = canvas.getContext(&#39;2d&#39;);
ctx.strokeStyle = &#39;rgb(150,0,0)&#39;;
ctx.fillStyle   = &#39;rgb(0,150,0)&#39;;
ctx.lineWidth   = 7;
roundedRect(ctx, 15, 15, 160, 120, 20, true, true);</pre>

</details>

<p>In this example, each call to ctx.arcTo(…) draws a side plus a
corner. This makes us suspect that the arcTo() method has been designed
primarily for drawing rounded rectangles…</p>

<h4>Example #3: comparison between lineTo and arcTo</h4>
<p>This example at JS Bin is the same as the previous one, except that we
added at the end of the roundedRect function the same lines of code that
draw the rounded rectangle, but using lineTo instead of arcTo. Just take
a look!</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~ 155. comparison between arcto and lineto (212) ~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image155.webp"
  loading="lazy"
  title="Comparison between lineTo and arcTo"
  alt="Comparison between lineTo and arcTo."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Comparison between lineTo and arcTo - Example #3&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      var roundedRect=function(ctx,x,y,width,height,radius,fill,stroke)
      {
      ctx.beginPath();
      // draw top and top right corner
      ctx.moveTo(x+radius,y);
      ctx.arcTo(x+width,y,x+width,y+radius,radius);
      // draw right side and bottom right corner
      ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius);
      // draw bottom and bottom left corner
      ctx.arcTo(x,y+height,x,y+height-radius,radius);
      // draw left and top left corner
      ctx.arcTo(x,y,x+radius,y,radius);
      if(fill){
        ctx.fill();
      }
      if(stroke){
        ctx.stroke();
      }
      // Draws the square using lineTo instead of arcTo,
      // just to compare both methods
      ctx.save();
      ctx.strokeStyle=&quot;pink&quot;;
      ctx.lineWidth=3; // ou ce que tu veux
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+width, y);
      ctx.lineTo(x+width, y+height);
      ctx.lineTo(x, y+height);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
      }
      var canvas=document.getElementById(&#39;myCanvas&#39;);
      var ctx=canvas.getContext(&#39;2d&#39;);
      ctx.strokeStyle=&#39;rgb(150,0,0)&#39;;
      ctx.fillStyle=&#39;rgb(0,150,0)&#39;;
      ctx.lineWidth=7;
      roundedRect(ctx,15,15,160,120,20,true,true);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>
<p>Red = arcTo and Pink = lineTo</p>

<h4>Example #4: use the unrounded vertices in arcTo</h4>
<p>For drawing a rounded square, this code also works:</p>

<pre>ctx.moveTo(x+radius, y);
ctx.arcTo(x+width, y,x+width, y+height, radius);
ctx.arcTo(x+width, y+height, x, y+height, radius); 
ctx.arcTo(x, y+height, x, y,radius);
ctx.arcTo(x, y, x+width, y,radius);</pre>

<p>Which might be easier than trying to figure out where the arc will end like this:</p>

<pre>ctx.moveTo(x+radius, y);
ctx.arcTo(x+width, y, x+width, y+radius, radius);
ctx.arcTo(x+width, y+height, x+width-radius, y+height,radius); 
ctx.arcTo(x, y+height, x, y+height-radius, radius);
ctx.arcTo(x, y, x+radius, y,radius);</pre>

<p>This could be particularly helpful if you are dealing with something other than a rectangle, like this rounded triangle:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 156. rounded triangle example (213) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image156.webp"
  loading="lazy"
  title="Example: rounded triangle"
  alt="Example: rounded triangle."
  style="width:40%;" />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Use the unrounded vertices in arcTo - Example #4&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      var roundedTriangle=function(ctx,x1,y1,x2,y2,x3,y3,radius,fill,stroke)
      {
        ctx.beginPath();
        // start at the middle of the side between x1,y1 and x2,y2
        ctx.moveTo((x1+x2)/2,(y1+y2)/2);
        // go around the x2,y2 vertex
        ctx.arcTo(x2,y2,x3,y3,radius);
        // go around the x3,y3 vertex
        ctx.arcTo(x3,y3,x1,y1,radius);
        // go around the x1,y1 vertex
        ctx.arcTo(x1,y1,x2,y2,radius);
        // and close the triangle with a line to the starting point
        ctx.lineTo((x1+x2)/2,(y1+y2)/2);
        if(fill){
          ctx.fill();
        }
        if(stroke){
          ctx.stroke();
        }
      }
      var canvas=document.getElementById(&#39;myCanvas&#39;);
      var ctx=canvas.getContext(&#39;2d&#39;);
      ctx.strokeStyle=&#39;rgb(150,0,0)&#39;;
      ctx.fillStyle=&#39;rgb(0,150,0)&#39;;
      ctx.lineWidth=7;
      roundedTriangle(ctx,200,15,300,150,15,100,20,true,true);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-10">3.4.10 Quadratic Curves</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Introduction</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~ 157. html5 canvas quadratic curve diagram (214) ~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image157.webp"
  loading="lazy"
  style="width:40%;"
  title="HTML5 Canvas Quadratic Curve Diagram. Control, context & ending points"
  alt="HTML5 Canvas Quadratic Curve Diagram. Control, context & ending points." />

<p>(Picture taken from the <a
href="https://www.html5canvastutorials.com/tutorials/html5-canvas-quadratic-curves/" target="_blank" rel="noopener noreferrer">HTML5
Canvas Tutorials</a> Web site)</p>
<p>Quadratic curves are defined by a starting point (called a “context
point”), a control point, and an ending point. The curve fits the
tangents between the context and control points and between the control
and ending points.</p>
<p>The context point may be defined by a call to the moveTo(x, y) method
of the context, or it may be the ending point of a previous path, if
we’re drawing a path made of several shapes. For example, drawing a line
and a quadratic curve will make the endpoint of the line the context
point for the quadratic curve.</p>
<p>The control point controls the curvature - if we move the control
point farther we get a sharper curve.</p>

<h4>Typical use:</h4>

<pre>context.moveTo(contextX, contextY);
context.quadraticCurveTo(controlX, controlY, endX, endY);
// Optional : set lineWidth and stroke color
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
// Draw!
context.stroke();</pre>

<h4>Examples</h4>

<h4>Example #1: quadratic curve</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 158. quadratic curve (215) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image158.webp"
  loading="lazy"
  style="width:40%;"
  title="Quadratic curve example"
  alt="Quadratic curve example." />

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas=document.querySelector(&#39;#myCanvas1&#39;);
var context=canvas.getContext(&#39;2d&#39;);
context.beginPath();
context.moveTo(100, 20);
context.quadraticCurveTo(230, 200, 250, 20);
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
context.stroke();</pre>

</details>

<p>We set a starting point in <i>line 6</i>: moveTo(…), then set the
control and ending points with a call to quadraticCurve(…), at <i>line
7</i>, then set some properties for color, thickness, and finally we
call the stroke() method for drawing the curve.</p>

<h4>Example #2: lines connected with a quadratic curve</h4>

<p>Try this:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~ 159. example: lines connected with quadratic curve (216) ~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image159.webp"
  loading="lazy"
  style="width:40%;"
  title="Example: Lines connected with a quadratic curve"
  alt="Example: Lines connected with a quadratic curve." />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;title&gt;Lines connected with a quadratic curve - Example #2&lt;/title&gt;
   &lt;/head&gt;
 &lt;body&gt;
   &lt;canvas id=&quot;myCanvas1&quot; height = 400 width=&quot;800&quot;&gt;Your browser does not support the 
   canvas tag.&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
      var canvas=document.querySelector(&#39;#myCanvas1&#39;);
      var context=canvas.getContext(&#39;2d&#39;);
      context.beginPath();
      context.moveTo(100, 20);
      context.lineTo(200, 80);
      context.quadraticCurveTo(230, 200, 250, 20);
      context.lineTo(500, 90);
      context.lineWidth = 5;
      context.strokeStyle = &quot;#0000ff&quot;;
      context.stroke();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>context.beginPath();
context.moveTo(100, 20);
context.lineTo(200, 80);
context.quadraticCurveTo(230, 200, 250, 20);
context.lineTo(500, 90);
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
context.stroke();</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-11">3.4.11 Curved Arrows</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>We propose a useful function for drawing curved arrows. See this example:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~ 160. example: useful function for drawing curved arrows (217) ~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image160.webp"
  loading="lazy"
  style="width:40%;"
  title="Example: useful function for drawing curved arrows"
  alt="Example: useful function for drawing curved arrows." />

<h4>JavaSscript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas = document.querySelector(&#39;#myCanvas&#39;);
var ctx = canvas.getContext(&#39;2d&#39;);
var contextX = 100;
var contextY = 10;
var endPointX = 200;
var endPointY = 120;
var controlPointX = 35;
var controlPointY = 70;
drawCurvedArrow(contextX, contextY,
endPointX, endPointY,
controlPointX, controlPointY,
3, // arrowWidth, try 30 for example !
20, // width of the arrow head, try smaller values, 10...
&#39;blue&#39;);
function drawCurvedArrow(startPointX, startPointY,
endPointX, endPointY,
quadPointX, quadPointY,
lineWidth,
arrowWidth,
color) {
  // GOOD PRACTICE: the function changes color and lineWidth -&gt; save context!
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  // angle of the end tangeant, useful for drawing the arrow head
  var arrowAngle = Math.atan2(quadPointX - endPointX, quadPointY - endPointY) + Math.PI;
  // start a new path
  ctx.beginPath();
  ctx.moveTo(startPointX, startPointY);
  ctx.quadraticCurveTo(quadPointX, quadPointY, endPointX, endPointY);
  ctx.moveTo(endPointX - (arrowWidth * Math.sin(arrowAngle - Math.PI / 6)),
  endPointY - (arrowWidth * Math.cos(arrowAngle - Math.PI / 6)));
  ctx.lineTo(endPointX, endPointY);
  ctx.lineTo(endPointX - (arrowWidth * Math.sin(arrowAngle + Math.PI / 6)),
  endPointY - (arrowWidth * Math.cos(arrowAngle + Math.PI / 6)));
  ctx.stroke();
  ctx.closePath();
  // GOOD PRACTICE -&gt; restore the context as we saved it at the beginning
  // of the function
  ctx.restore();
}</pre>

</details>

<h4>CSS source code:</h4>

<pre>#myCanvas {
  border: 1px solid black;
}</pre>

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Curved arrows&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;250&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Source code of the function that draws a curved arrow:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function drawCurvedArrow(startPointX, startPointY,
                         endPointX, endPointY,
                         quadPointX, quadPointY,
                         lineWidth,
                         arrowWidth,
                         color) {
    // BEST PRACTICE: the function changes color and lineWidth -&gt; save context!
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    // angle of the end tangeant, useful for drawing the arrow head
    var arrowAngle = Math.atan2(quadPointX - endPointX, quadPointY - endPointY) + Math.PI;
    // start a new path
    ctx.beginPath();
    // Body of the arrow
    ctx.moveTo(startPointX, startPointY);
    ctx.quadraticCurveTo(quadPointX, quadPointY, endPointX, endPointY);
    // Head of the arrow
    ctx.moveTo(endPointX - (arrowWidth * Math.sin(arrowAngle - Math.PI / 6)),
               endPointY - (arrowWidth * Math.cos(arrowAngle - Math.PI / 6)));
    ctx.lineTo(endPointX, endPointY);
    ctx.lineTo(endPointX - (arrowWidth * Math.sin(arrowAngle + Math.PI / 6)),
               endPointY - (arrowWidth * Math.cos(arrowAngle + Math.PI / 6)));
   ctx.stroke();
   ctx.closePath();
   // BEST PRACTICE -&gt; restore the context as we saved it at the beginning
   // of the function
   ctx.restore();
}</pre>

</details>

<p>This function takes as parameters the start and end points, the
control point of the curve, the arrow width, the width of the arrow
head.</p>
<p>It computes the angle of the arrow at its endpoint (<i>line 14</i>)
in order to compute the rotated endpoints of the two lines of the arrow
head (<i>lines 24</i> and <i>29</i>).</p>
<p>Notice that once again, as we modify the context properties (color,
lineWidth) in the body of the function, we save and restore the context
at the beginning / end of the function.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-4-12">3.4.12 Bézier curves</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Introduction</h4>

<p>Bézier curves are interesting. They are mostly used for drawing “S” shapes or asymmetric curves.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 161. bezier curve in 's' (219) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image161.webp"
  loading="lazy"
  style="width:35%;"
  title="Bezier curve in S"
  alt="Bezier curve in S." />

<p>(image taken from <a
href="https://blogs.sitepointstatic.com/examples/tech/canvas-curves/bezier-curve.html" target="_blank" rel="noopener noreferrer">SitePoint</a>)</p>
<p>Bézier curves are defined by a context point, like quadratic curves,
two control points that define two tangents, and an ending point.</p>
<p>The first part of the curve is tangential to the imaginary line
defined by the context point and the first control point. The second
part of the curve is tangential to the imaginary line defined by the
second control point and the ending point.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~ 162. bezier curve control points (219) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image162.webp"
  loading="lazy"
  style="width:40%;"
  title="Bezier curve control points"
  alt="Bezier curve control points." />

<p>(Picture taken from the <a
href="https://www.html5canvastutorials.com/tutorials/html5-canvas-bezier-curves/" 
target="_blank" rel="noopener noreferrer">HTML5 Canvas Tutorials</a> Web site)</p>

<p>The best way to understand how they work is to check out one of these
interactive applications:</p>

<ul>
  <li><a href="https://blogs.sitepointstatic.com/examples/tech/canvas-curves/bezier-curve.html" 
    target="_blank" rel="noopener noreferrer">Canvas Bézier Curve Example</a></li>
  <li><a href="http://lib.ivank.net/?p=demos&amp;d=bezier" target="_blank" rel="noopener noreferrer">
    IvanK Lib graphics demos</a></li>
  <li>Nice video tutorial: <a href="https://vimeo.com/106757336" target="_blank" rel="noopener noreferrer">
    Bézier curves under the hood</a></li>
</ul>

<h4>Typical usage of Bézier curves</h4>

<h4>JavaScript source code:</h4>

<pre>ctx.moveTo(contextX, contextY);
context.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
// Optional : set lineWidth and stroke color
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
// Draw!
ctx.stroke();</pre>

<h4>Examples</h4>

<h4>Example #1</h4>

<p>Try this:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 163. bezier curve: example 1 (220) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image163.webp"
  loading="lazy"
  style="width:40%;"
  title="Bezier curve: Example 1"
  alt="Bezier curve: Example 1." />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Bézier curve - Example #1&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas1&quot; height = 400 width=&quot;800&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      var canvas=document.querySelector(&#39;#myCanvas1&#39;);
      var context=canvas.getContext(&#39;2d&#39;);
      context.beginPath();
      context.moveTo(100, 20);
      // TRY uncommenting these lines !
      //context.lineTo(200, 80);
      //context.quadraticCurveTo(230, 200, 250, 20);
      context.bezierCurveTo(290, -40, 200, 200, 400, 100);
      //context.lineTo(500, 90);
      // TRY TO UNCOMMENT THIS LINE
      //context.closePath();
      context.lineWidth = 5;
      context.strokeStyle = &quot;#0000ff&quot;;
      context.stroke();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Code source:</h4>

<pre>context.beginPath();
context.moveTo(100, 20);
context.bezierCurveTo(290, -40, 200, 200, 400, 100);
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
context.stroke();</pre>

<h4>Example #2: path with bezier curve, quadratic curve and line in the same, closed path</h4>

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~ 164. path with bezier curve, quadratic curve & line in same, closed path  (221) ~~~~~-->
<img class="displayed"
  src="./images/image164.webp"
  loading="lazy"
  style="width:40%;"
  title="Path with Bezier and Quadratic curve and line in same, closed path"
  alt="Path with Bezier and Quadratic curve and line in same, closed path." />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Path with Bézier curve, quadratic curve and line in the same, closed path - Example #2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;canvas id=&quot;myCanvas1 height = 400 width=&quot;800&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;
    var canvas=document.querySelector(&#39;#myCanvas1&#39;);
    var context=canvas.getContext(&#39;2d&#39;);
    context.beginPath();
    context.moveTo(100, 20);
    context.lineTo(200, 160);
    context.quadraticCurveTo(230, 200, 250, 120);
    context.bezierCurveTo(290, -40, 300, 200, 400, 150);
    context.lineTo(500, 90);
    // TRY TO COMMENT THIS LINE
    context.closePath();
    context.lineWidth = 5;
    context.strokeStyle = &quot;#0000ff&quot;;
    context.stroke();
  &lt;/script&gt;
&lt;/body&gt;</pre>

</details>

<h4>Extract from JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>context.beginPath();
context.moveTo(100, 20);
context.lineTo(200, 160);
context.quadraticCurveTo(230, 200, 250, 120);
context.bezierCurveTo(290, -40, 300, 200, 400, 150);
context.lineTo(500, 90);
// TRY COMMENTING THIS LINE OUT
context.closePath();
context.lineWidth = 5;
context.strokeStyle = &quot;#0000ff&quot;;
context.stroke();</pre>

</details>

<p>In this example we use the closePath() method to draw a line between
the last path point and the first path point (<i>line 11</i>), so that
the drawing looks like a pair of goggles.</p>
<p>Note how the different parts are linked together and make a “path”:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 165. bezier curve maker tool (222) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image165.webp"
  loading="lazy"
  title="Interactive code that draws Bezier curves"
  alt="Interactive code that draws Bezier curves."
  style="width:40%;" />

<h4>Interesting, interactive tool for generating code that draws Bézier curves</h4>

<p>This Bézier tool (“HTML5 &lt;canvas&gt; bezierCurveTo command generator”) is
available <a href="https://www.victoriakirst.com/beziertool/" target="_blank" rel="noopener noreferrer">online</a>: try it!</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-1">3.5.1 Canvas Context: Colors</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>In previous examples, we saw how to set the current color using
the strokeStyle and fillStyle properties of the canvas context
object.</p>
<p>Let’s look at color in a little more detail, and see how we can use
gradients or patterns/textures/images (in other words: fill shapes or
fill the outline of the shapes with some images that repeat
themselves).</p>

<h4>Colors and transparency</h4>

<p>You can use <a href="https://www.w3.org/TR/css3-color/" target="_blank" rel="noopener noreferrer">
the same syntax for colors that is supported by CSS3</a>. The next lines show possible values/syntaxes.</p>

<pre>ctx.strokeStyle = &#39;red&#39;;
ctx.fillStyle = &quot;#00ff00&quot;;
ctx.strokeStyle = &quot;rgb(0, 0, 255)&quot;;
ctx.fillStyle = &quot;rgba(0, 0, 255, 0.5)&quot;;</pre>

<p>Note that:</p>

<ul>
  <li>All values are strings;</li>
  <li><i>Line 4</i> defines a “transparent color”, the “a” of “rgba” means “alpha channel”. Its 
    value is between 0 and 1, where 0 means “completely transparent” and 1 means “opaque”.</li>
</ul>

<h4>Here is an example that shows how to draw different filled rectangles in blue, with different 
levels of transparency:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 166. colors and transparency example (223) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image166.webp"
  loading="lazy"
  style="width:40%;"
  title="Colors and transparency example"
  alt="Colors and transparency example." />

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Colors and transparency&lt;/title&gt;
  &lt;style&gt;
   #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;script&gt;
  var canvas, ctx;
  function init() {
    // This function is called after the page is loaded
    // 1 - Get the canvas
    canvas = document.getElementById(&#39;myCanvas&#39;);
    // 2 - Get the context
    ctx=canvas.getContext(&#39;2d&#39;);
    // 3 - we can draw
    drawSomething();
  }
  function drawSomething() {
    // set the global context values
    ctx.fillStyle=&#39;rgba(0, 0, 255, 0.2)&#39;;
    // Draw the two filled red rectangles
    ctx.fillRect(150, 20, 200, 100);
    ctx.fillRect(100, 50, 200, 100);
    ctx.fillStyle = &quot;blue&quot;;
    ctx.fillRect(50, 100, 200, 100);
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;220&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-2">3.5.2 Canvas Context: Linear Gradients</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>It is possible to define the stroke or the fill style as a “gradient”, a set 
of interpolated colors, like in this example below:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~ 167. define stroke fill style as 'gradient' (224) ~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image167.webp"
  loading="lazy"
  style="width:40%;"
  title="Define stroke fill style as 'gradient'"
  alt="Define stroke fill style as 'gradient'." />

<h4>JavaScript source code:</h4>

<details>
  <summary><b>JavaScript code extract!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // The gradient we create is also a global variable, we
  // will be able to reuse it for drawing different shapes
  // in different functions
  grdFrenchFlag = ctx.createLinearGradient(0, 0, 300, 0);
  // Try adding colors with first parameter between 0 and 1
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  draw();
}
function draw() {
  ctx.fillStyle = grdFrenchFlag;
  ctx.fillRect(0, 0, 300, 200);
}</pre>

</details>

<h4>HTML source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Linear gradients&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>A linear gradient is seen as an “invisible” rectangle in which a set of
colors are interpolated along a line.</h4>

<p>The gradient becomes visible when we draw shapes on top of the
invisible gradient, and when the fillStyle or strokeStyle property has
for value this gradient.</p>

<h4>How to create gradients</h4>

<p>There are 3 steps:</p>

<h4>Step #1: define a linear gradient</h4>

<h4>Syntax:</h4>

<pre>ctx.createLinearGradient(x0,y0,x1,y1);</pre>

<p>… where the (x0, y0) and (x1, y1) parameters define “the direction of
the gradient” (as a vector with a starting and an ending point). This
direction is an invisible line along which the colors that compose the
gradient will be interpolated.</p>

<h4>Let’s see an example:</h4>

<pre>grdFrenchFlag = ctx.createLinearGradient(0, 0, 300, 0);</pre>

<p>This line defines the direction of the gradient: a virtual, invisible
line that goes from the top left corner of the canvas (0, 0) to the
top right corner of the canvas (300, 0). The interpolated colors will
propagate along this line. </p>
<p>If this gradient is going to be reused by different functions, it is
good practice to create/initialize it in a function called when the page
is loaded and to store it in a global variable.</p>

<h4>Step #2: add a number of “color stops” to this gradient</h4>

<p>We will add a set of “colors” and “stops” to this gradient. The stops
go from 0 (beginning of the virtual line defined just above), to 1 (end
of the virtual line). A color associated with a value of 0.5 will be
right in the middle of the virtual line.</p>
<p>Here is an example that corresponds to an interpolated version of the
French flag, going from blue to white, then to red, with proportional
intervals. We define three colors, blue at position 0, white at position
0.5 and red at position 1:</p>

<pre>grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
grdFrenchFlag.addColorStop(1, &quot;red&quot;);</pre>

<h4>Step 3: draw some shapes</h4>

<p>First, let’s set the fillStyle or strokeStyle of the context with
this gradient, then let’s draw some shapes “on top of the gradient”.</p>
<p>In our example, the gradient corresponds to an invisible rectangle
that fills the canvas. If we draw a rectangle of the canvas size, it
should be filled with the entire gradient:</p>

<pre>ctx.fillStyle = grdFrenchFlag;
ctx.fillRect(0, 0, 300, 200);</pre>

<p>The result is shown in the <a href="https://codepen.io/w3devcampus/pen/WNpPZVO" 
target="_blank" rel="noopener noreferrer">above pen</a>: a big rectangle that fills 
the whole canvas, with colors going from blue (left) to white (middle) to red (right).</p>

<h4>Examples</h4>

<h4>Example #1: changing the direction of the gradient</h4>

<p>If you modify the source code that defines the direction of the gradient as follows…</p>

<pre>grdFrenchFlag = ctx.createLinearGradient(0, 0, 300, 200);</pre>

<p>… then you will define a gradient that goes from the top left corner of
the canvas to the bottom right of the canvas. Let’s see what it does:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~ 168. example 1 draw gradient top left to bottom right (226) ~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image168.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 1 draw gradient from top left to bottom right"
  alt="Example 1 draw gradient from top left to bottom right." />

<h4>Example #2: drawing shapes that do not cover the whole gradient</h4>

<p>Instead of drawing a filled rectangle that covers the whole surface of
the canvas, let’s draw several smaller rectangles:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~ 169. example 2 draw smaller rectangles (226) ~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image169.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 2 draw smaller rectangles - red & blue"
  alt="Example 2 draw smaller rectangles - red & blue." />

<p>Note that the canvas has its default background color where we did not
draw anything. And where we have drawn rectangles, we can see “through”
and the colors from the gradient are visible.</p>

<h4>Here is the code that draws the checkboard:</h4>

<pre>ctx.fillStyle = grdFrenchFlag;
ctx.fillRect(0, 0, 50, 50);
ctx.fillRect(100, 0, 50, 50);
ctx.fillRect(200, 0, 50, 50);
ctx.fillRect(50, 50, 50, 50);
ctx.fillRect(150, 50, 50, 50);
ctx.fillRect(250, 50, 50, 50);
ctx.fillRect(0, 100, 50, 50);
ctx.fillRect(100, 100, 50, 50);
ctx.fillRect(200, 100, 50, 50);
ctx.fillRect(50, 150, 50, 50);
ctx.fillRect(150, 150, 50, 50);
ctx.fillRect(250, 150, 50, 50);</pre>

<p>This code is rather ugly isn’t it? It would have been better to use a loop…</p>

<h4>Here is function that draws a chessboard:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>// n = number of cells per row/column
function drawCheckboard(n) {
  ctx.fillStyle = grdFrenchFlag;
  var l = canvas.width;
  var h = canvas.height;
  var cellWidth = l / n;
  var cellHeight = h / n;
  for(i = 0; i &lt; n; i++) {
    for(j = i % 2; j &lt; n; j++) {
      ctx.fillRect(cellWidth*i, cellHeight*j, cellWidth, cellHeight);
    }
  }
}</pre>

</details>

<p>The two loops (<i>lines 11-15</i>) draw only one cell out of two (see
the j = i % 2 at <i>line 12</i>). i is the column number and if the
column is odd or even, either we draw or we do not draw a rectangle.</p>

<p>This code is much more complex than the previous one, taking 16 lines
instead of 13, but is much more powerful. Try to call the function with
a value of 10, 20, or 2…</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 170. draw checkboard (227) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image170.webp"
  loading="lazy"
  style="width:40%;"
  title="Draw red and blue checkerboard"
  alt="Draw red and blue checkerboard." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // The gradient we create is also a global variable, we
  // will be able to reuse it for drawing different shapes
  // in different functions
  grdFrenchFlag = ctx.createLinearGradient(0, 0, 300, 200);
  // Try adding colors with first parameter between 0 and 1
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  drawCheckboard(10);
}
// n = number of cells per row/column
function drawCheckboard(n) {
  ctx.fillStyle = grdFrenchFlag;
  ctx.lineWidth=10;
  var l = canvas.width;
  var h = canvas.height;
  var cellWidth = l / n;
  var cellHeight = h / n;
  for(i = 0; i &lt; n; i++) {
    for(j = i % 2; j &lt; n; j+=2) {
      ctx.fillRect(cellWidth*i, cellHeight*j, cellWidth, cellHeight);
    }
  }
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Drawing shapes that do not cover the whole gradient - Example #2 bis&lt;/title&gt;
    &lt;style&gt;
      #myCanvas1 {
        border: 1px solid black;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;init();&quot;&gt;
    &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.
    &lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Example #3: drawing outlined shapes with gradients</h4>

<p>Just as we used fillStyle and fillRect for drawing rectangles filled
with a gradient, we can also use strokeStyle and strokeRect in order to
draw wireframed rectangles. In the next example, which is just a
variation of the previous one, we have used the lineWidth property to
set the outline of the rectangles at 5 pixels:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~ 171. example 3 using strokestyle and strokerect to draw rectangles (228) ~~~~~~~~~~-->
<img class="displayed"
  src="./images/image171.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 3 draw rectangles using strokeStyle and strokeRect"
  alt="Example 3 draw rectangles using strokeStyle and strokeRect." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // The gradient we create is also a global variable, we
  // will be able to reuse it for drawing different shapes
  // in different functions
  grdFrenchFlag = ctx.createLinearGradient(0, 0, 300, 200);
  // Try adding colors with first parameter between 0 and 1
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  drawCheckboard(5);
}
// n = number of cells per row/column
function drawCheckboard(n) {
  ctx.strokeStyle = grdFrenchFlag;
  ctx.lineWidth=10;
  var l = canvas.width;
  var h = canvas.height;
  var cellWidth = l / n;
  var cellHeight = h / n;
  for(i = 0; i &lt; n; i++) {
    for(j = i % 2; j &lt; n; j+=2) {
      ctx.strokeRect(cellWidth*(i), cellHeight*j, cellWidth, cellHeight);
    }
  }
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Drawing outlined shapes with gradients - Example #3&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
   &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas   tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Extract from source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function drawCheckboard(n) {
  ctx.strokeStyle = grdFrenchFlag;
  ctx.lineWidth=10;
  ...
  for(i = 0; i &lt; n; i++) {
    for(j = i % 2; j &lt; n; j++) {
      ctx.strokeRect(cellWidth*i, cellHeight*j, cellWidth, cellHeight);
    }
  }
}</pre>

</details>

<h4>Example #4: what happens if we define a gradient smaller than the
canvas?</h4>

<p>Let’s go back to the very first example on this page - the one with
the blue-white-red interpolated French flag. This time we will define a
smaller gradient. Instead of going from (0, 0) to (300, 0), it will go
from (100, 0) to (200, 0), while the canvas remains the same
(width=300, height=200).</p>

<pre>grdFrenchFlag = ctx.createLinearGradient(100, 0, 200, 0);</pre>

<p>Like in the first example we will draw a filled rectangle that is the
same size as the canvas:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 172. example 4 draw filled rectangle (230) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image172.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 4 draw filled rectangles"
  alt="Example 4 draw filled rectangles." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // The gradient we create is also a global variable, we
  // will be able to reuse it for drawing different shapes
  // in different functions
  grdFrenchFlag = ctx.createLinearGradient(100, 0, 200, 0);
  // Try adding colors with first parameter between 0 and 1
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  draw();
}
function draw() {
  ctx.fillStyle = grdFrenchFlag;
  ctx.fillRect(0, 0, 300, 200);
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Defining a gradient smaller than the canvas - Example #4&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
   &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>We notice that “before” the gradient starts, the first color of the
gradient is repeated without any interpolation (columns 0-100 are all
blue), then we “see through” and the gradient is drawn (columns
100-200), then the last color of the gradient is repeated without any
interpolation (columns 200-300 are red).</p>

<h4>Example #5: what happens if we define a gradient bigger than the canvas?</h4>

<p>Nothing special; we will “see through the drawn shapes”, and
the parts of the gradient that are located in the canvas area will be
shown. You can try this example that defines a gradient twice the size
of the canvas:</p>

<pre>grdFrenchFlag = ctx.createLinearGradient(0, 0, 600, 400);</pre>

<p>And if we draw the same rectangle with the canvas size, here is the
result:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 173. example 5 canvas size (231) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image173.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 5 draw same rectangle with the canvas size"
  alt="Example 5 draw same rectangle with the canvas size." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // The gradient we create is also a global variable, we
  // will be able to reuse it for drawing different shapes
  // in different functions
  grdFrenchFlag = ctx.createLinearGradient(0, 0, 600, 400);
  // Try adding colors with first parameter between 0 and 1
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  draw();
}
function draw() {
  ctx.fillStyle = grdFrenchFlag;
  ctx.fillRect(0, 0, 300, 200);
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Defining a gradient bigger than the canvas - Example #5&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>The red color is beyond the bottom right corner…. we see only the top
left quarter of the gradient.</p>

<h4>Example #6: drawing shapes that share the same gradient as a whole</h4>

<p>This time, we would like to draw the chessboard with the gradient in
each cell. How can we do this with one single gradient?</p>
<p>We can’t! At least we can’t without recreating it for each cell!</p>
<p>It suffices to create a new gradient before drawing each filled
rectangle, and set it with the starting and ending point of its
direction/virtual line accordingly to the rectangle coordinates. Try
this:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~ 174. example 6 draw shapes that share gradient (232) ~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image174.webp"
  loading="lazy"
  style="width:40%;"
  title="Example 6 draw shapes that share gradient"
  alt="Example 6 draw shapes that share gradient." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grdFrenchFlag;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(#myCanvas1);
  ctx = canvas.getContext(&#39;2d&#39;);
  drawCheckboard(5);
}
function setGradient(x, y, width, height) {
  grdFrenchFlag = ctx.createLinearGradient(x, y, width, height);
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  ctx.fillStyle = grdFrenchFlag;
}
// n = number of cells per row/column
function drawCheckboard(n) {
  var l = canvas.width;
  var h = canvas.height;
  var cellWidth = l / n;
  var cellHeight = h / n;
  for(i = 0; i &lt; n; i+=2) {
    for(j = 0; j &lt; n; j++) {
      var x = cellWidth*(i+j%2);
      var y = cellHeight*j;
      setGradient(x, y, x+cellWidth, y+cellHeight);
      ctx.fillRect(x, y, cellWidth, cellHeight);</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Drawing shapes that share the same gradient as a whole - Example #6&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;/head&gt;
  &lt;body onload=&quot;init();&quot;&gt;
    &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Extract from source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function setGradient(x, y, width, height) {
  grdFrenchFlag = ctx.createLinearGradient(x, y, width, height);
  grdFrenchFlag.addColorStop(0, &quot;blue&quot;);
  grdFrenchFlag.addColorStop(0.5, &quot;white&quot;);
  grdFrenchFlag.addColorStop(1, &quot;red&quot;);
  // set the new gradient to the current fillStyle
  ctx.fillStyle = grdFrenchFlag;
}
// n = number of cells per row/column
function drawCheckboard(n) {
  var l = canvas.width;
  var h = canvas.height;
  var cellWidth = l / n;
  var cellHeight = h / n;
  for(i = 0; i &lt; n; i+=2) {
    for(j = 0; j &lt; n; j++) {
      var x = cellWidth*(i+j%2);
      var y = cellHeight*j;
      setGradient(x, y, x+cellWidth, y+cellHeight);
      ctx.fillRect(x, y, cellWidth, cellHeight);
    }
  }
}</pre>

</details>

<p>We wrote a function setGradient(startX, startY, endX, endY) that
creates a gradient and set the fillStyle context property so that any
filled shape drawn will have this gradient.</p>
<p>In the drawCheckBoard(…) function we call it just before drawing
rectangles. In this way, each rectangle is drawn using its own
gradient.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-3">3.5.3 Canvas Context: Radial Gradients</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>Radial gradients are for creating gradients that propagate/interpolate colors along circles instead of
propagating/interpolating along a virtual line, like linear gradients.</p>

<h4>Here is an example of a radial gradient that interpolates the color of the rainbow:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~ 175. example radial gradient interpolates color of rainbow (234) ~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image175.webp"
  loading="lazy"
  style="width:40%;"
  title="Example radial gradient which interpolates the color of the rainbow"
  alt="Example radial gradient which interpolates the color of the rainbow." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grd;
function init() {
// Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  grd = ctx.createRadialGradient(150, 100, 30, 150, 100, 100);
  grd.addColorStop(0, &quot;red&quot;);
  grd.addColorStop(0.17, &quot;orange&quot;);
  grd.addColorStop(0.33, &quot;yellow&quot;);
  grd.addColorStop(0.5, &quot;green&quot;);
  grd.addColorStop(0.666, &quot;blue&quot;);
  grd.addColorStop(1, &quot;violet&quot;);
  draw();
}
function draw() {
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 300, 200);
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Radial gradients&lt;/title&gt;
    &lt;style&gt;
      #myCanvas1 {
        border: 1px solid black;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;init();&quot;&gt;
      &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>The gradient is defined as follows:</h4>

<pre>var grd = context.createRadialGradient(150, 100, 30, 150, 100, 100);
grd.addColorStop(0, &quot;red&quot;);
grd.addColorStop(0.17, &quot;orange&quot;);
grd.addColorStop(0.33, &quot;yellow&quot;);
grd.addColorStop(0.5, &quot;green&quot;);
grd.addColorStop(0.666, &quot;blue&quot;);
grd.addColorStop(1, &quot;violet&quot;);
context.fillStyle = grd;</pre>

<p>The method from the context object createRadialGradient(cx1, cy1,
radius1, cx2, cy2, radius2) takes as the first three parameters the
“starting” circle of the gradient, and as the three last parameters, the
“ending circle”.</p>

In the above example, the gradients starts at a circle located at (150,
100), with a radius of 30, and propagates to a circle with the same
center as the first (150, 100), but with a bigger radius of 100, as
shown below:
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 176. above example with color stops (235) ~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image176.webp"
  loading="lazy"
  style="width:40%;"
  title="Radial gradient"
  alt="Radial gradient." />

<p>We added color stops using a method similar to that used for linear gradients.</p>

<h4>What happens if the circles are not located at the same place?</h4>

<p>You get some nice effects; here we set the second circle’s center 60 pixels 
to the right of the first circle’s center (cx = 210 instead of 150):</p>

<pre>grd = ctx.createRadialGradient(150, 100, 30, 210, 100, 100);</pre>

<h4>Here is the result:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~ 177. 2nd circle center to the right of 1st circle (235) ~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image177.webp"
  loading="lazy"
  style="width:40%;"
  title="Effects from 2nd circle center to the right of the 1st circle center"
  alt="Effects from 2nd circle center to the right of the 1st circle center." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, grd;
function init() {
  // Good practice 1: set global vars canvas, ctx, gradients, etc here
  canvas = document.querySelector(&#39;#myCanvas1&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  grd = ctx.createRadialGradient(150, 100, 30, 210, 100, 100);
  grd.addColorStop(0, &quot;red&quot;);
  grd.addColorStop(0.17, &quot;orange&quot;);
  grd.addColorStop(0.33, &quot;yellow&quot;);
  grd.addColorStop(0.5, &quot;green&quot;);
  grd.addColorStop(0.666, &quot;blue&quot;);
  grd.addColorStop(1, &quot;violet&quot;);
  draw();
}
function draw() {
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 300, 200);
}</pre>

</details>

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Radial gradients with offset circles&lt;/title&gt;
  &lt;style&gt;
    #myCanvas1 {
      border: 1px solid black;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas1&quot; width=&quot;300&quot; height=200&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>What happens if the gradient is smaller or larger than the shapes we draw?</h4>

<p>A gradient is an invisible shape on the screen: the radial gradient
is made of two circles: an inner and an outer circle. Between these two
circles, colors are interpolated.</p>
<p>We call the “first color” the color defined for the inner circle, the
“last color” the last color of the gradient, that corresponds to the
outer circle:</p>

<ul>
  <li>The color inside the first circle will be the first color. In our example 
    above, the first color is red: and the small circle of the gradient in our 
    example is filled in red!</li>
  <li>The color outside the outer circle will be the last color of the gradient 
    - which is not interpolated. The last color in our example is purple, and 
    it fills the rest of the filled rectangle area “after” the external circle 
    of the gradient.</li>
  <li>The colors between the two circles will be interpolated.</li>
</ul>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-4">3.5.4 Canvas Context: Patterns/Textures</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Principle</h4>

<p>The principle of “pattern” drawing is based on repeating an image (if
the image is smaller than the surface of the shape you are going to
draw) for filling the surface of objects to be drawn (either filled or
stroked).</p>
<p>To illustrate this principle, in the next examples, we are going to
draw rectangles using a pattern.</p>
<p>There are a few steps we have to take before doing this:</p>

<ol type="1">
  <li><b>Create a JavaScript image object</b></li>
</ol>

<pre>var imageObj = new Image();</pre>

<ol start="2" type="1">
  <li><b>Define a callback function that will be called once the image has been 
    fully loaded</b> in memory; we cannot draw before the image has been loaded.</li>
</ol>

<pre>imageObj.onload = function(){
  ...
}</pre>

<ol start="3" type="1">
  <li><b>Set the source of this image to the URL of the pattern</b>:</li>
</ol>

<pre>imageObj.src = &quot;https://www.myserver.com/myRepeatablePattern.png&quot;;</pre>

<ol start="4" type="1">
  <li><b>Create a pattern object from the loaded image:</b></li>
</ol>

<p>As soon as step 3 is executed, an HTTP request is sent in background
by the browser, and when the image is loaded in memory, the callback
defined at step 2 is called. We create a pattern object inside, from the
loaded image:</p>

<pre>// callback called asynchronously, after the src attribute of imageObj is set
imageObj.onload = function(){ 
    // We enter here when the image is loaded, we create a pattern object.
    // It is good practice to set this as a global variable, easier to share
    pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);
};</pre>

<ol start="5" type="1">
  <li><b>Inside the callback function (or inside a function called from inside 
    the callback), we can finally draw</b>:</li>
</ol>

<pre>// callback called asynchronously, after the src attribute of imageObj is set
imageObj.onload = function(){
  pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);
  // Draw a textured rectangle
  ctx.fillStyle = pattern1;
  ctx.fillRect(10, 10, 500, 800);
};</pre>

<h4>Examples</h4>

<h4>Example #1: draw two rectangles with a pattern (one filled, one stroked)</h4>

<p>Here we have two rectangles drawn using a pattern (an image that can be 
repeated along the X and Y axis). The first is a filled rectangle while the 
second is “stroked” with a lineWidth of 20 pixels:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~ 178. filled rectange and stroked rectangle with linewidth 20 (238) ~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image178.webp"
  loading="lazy"
  style="width:40%;"
  title="Filled rectange and a stroked rectangle with lineWidth=20"
  alt="Filled rectange and a stroked rectangle with lineWidth=20." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, pattern1;
function init() {
  canvas = document.querySelector(&#39;#myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // We need 1) to create an empty image object, 2) to set a callback function
  // that will be called when the image is fully loaded, 3) to create a
  // pattern object, 4) to set the fillStyle or the strokeStyle property of
  // the context with this pattern, 5) to draw something
  // WE CANNOT DRAW UNTIL THE IMAGE IS FULLY LOADED -&gt; draw from inside the
  // onload callback only !
  // Allocate an image
  var imageObj = new Image();
  // callback called asynchronously, after the src attribute of imageObj is set
  imageObj.onload = function(){
    // We enter here only when the image has been loaded by the browser
    // Pattern creation using the image object
    // Instead of &quot;repeat&quot;, try different values : repeat-x, repeat-y,
    // or no-repeat, You may draw larger shapes in order to see
    // different results
    // It is a good practice to leave this as a global variable if it
    // will be reused by other functions
    pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);
    // Draw a textured rectangle
    ctx.fillStyle = pattern1;
    ctx.fillRect(10, 10, 200, 200);
    // And a wireframe one
    ctx.lineWidth=20;
    ctx.strokeStyle=pattern1;
    ctx.strokeRect(230, 20, 150, 100);
  };
  // This will tell the browser to send an asynchronous request.
  // When the browser will get an answer, the callback above will be called
  imageObj.src = &quot;https://mainline.i3s.unice.fr/mooc/pattern1.jpg&quot;;
}</pre>

</details>

<h4>HTML</h4>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Drawing two rectangles with a pattern - Example #1&lt;/title&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag. &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, pattern1;
function init() {
  canvas = document.querySelector(&#39;#myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // We need 1) to create an empty image object, 2) to set a callback function
  // that will be called when the image is fully loaded, 3) to create a
  // pattern object, 4) to set the fillStyle or the strokeStyle property of
  // the context with this pattern, 5) to draw something
  // WE CANNOT DRAW UNTIL THE IMAGE IS FULLY LOADED -&gt; draw from inside the
  // onload callback only !
  // 1 - Allocate an image
var imageObj = new Image();
  // 2 - callback called asynchronously, after the src attribute of imageObj
  // is set
  imageObj.onload = function(){
      // We enter here only when the image has been loaded by the browser
      // 4 - Pattern creation using the image object
      // Instead of &quot;repeat&quot;, try different values : repeat-x, repeat-y,
      // or no-repeat, You may draw larger shapes in order to see
      // different results
      // It is good practice to leave this as a global variable if it
      // will be reused by other functions
      pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);
      // 5 - Draw things. Here a textured rectangle
      ctx.fillStyle = pattern1;
      ctx.fillRect(10, 10, 200, 200);
      // ... And a wireframe one
      ctx.lineWidth=20;
      ctx.strokeStyle=pattern1;
      ctx.strokeRect(230, 20, 150, 100);
  };
  // 3 - Send the request to load the image
  // Setting the src attribute will tell the browser to send an asynchronous
  // request.
  // When the browser gets an answer, the callback above will be called
  imageObj.src = &quot;https://mainline.i3s.unice.fr/mooc/pattern1.jpg&quot;;
}</pre>

</details>

<h4>Example 2: the repeatability of a pattern</h4>

<p>To “better” see the repeatability of the pattern, here is the same example with a 1000x1000 pixel wide canvas:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~ 179. 1000 by 1000 pixel wide canvas (239) ~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image179.webp"
  loading="lazy"
  style="width:40%;"
  title="1000 by 1000 pixel wide canvas"
  alt="1000 by 1000 pixel wide canvas." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx, pattern1;
function init() {
  canvas = document.querySelector(&#39;#myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // We need 1) to create an empty image object, 2) to set a callback function
  // that will be called when the image is fully loaded, 3) to create a
  // pattern object, 4) to set the fillStyle or the strokeStyle property of
  // the context with this pattern, 5) to draw something
  // WE CANNOT DRAW UNTIL THE IMAGE IS FULLY LOADED -&gt; draw from inside the
  // onload callback only !
  // Allocate an image
  var imageObj = new Image();
  // callback called asynchronously, after the src attribute of imageObj is set
  imageObj.onload = function(){
    // We enter here only when the image has been loaded by the browser
    // Pattern creation using the image object
    // Instead of &quot;repeat&quot;, try different values : repeat-x, repeat-y,
    // or no-repeat, You may draw larger shapes in order to see
    // different results
    // It is a good practice to leave this as a global variable if it
    // will be reused by other functions
    pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);
    // Draw a textured rectangle
    ctx.fillStyle = pattern1;
    ctx.fillRect(10, 10, 500, 800);
    // And a wireframe one
    ctx.lineWidth=50;
    ctx.strokeStyle=pattern1;
    ctx.strokeRect(650, 20, 300, 800);
  };
  // This will tell the browser to send an asynchronous request.
  // When the browser will get an answer, the callback above will be called
  imageObj.src = &quot;https://mainline.i3s.unice.fr/mooc/pattern1.jpg&quot;;
}</pre>

</details>

<h4>HTML:</h4>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Repeatability of a pattern - Example #2&lt;/title&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;1000&quot; height=&quot;1000&quot;&gt;
  Your browser does not support the canvas tag. &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<h4>You can change the way the pattern is repeated by modifying the second 
parameter of this method:</h4>

<pre>pattern1 = ctx.createPattern(imageObj, &quot;repeat&quot;);</pre>

<p>Please try: repeat-x, repeat-y or no-repeat as acceptable values. Just change 
this line in the online example and you will see live results.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-5">3.5.5 A Multiple Image Loader</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Draw with multiple patterns? We need to load all of them before drawing!</h4>

<p>Below are 4 rectangles drawn with 4 different patterns.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~ 180. four rectangles drawn with different patterns (241) ~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image180.webp"
  loading="lazy"
  style="width:35%;"
  title="Four rectangles drawn with different patterns"
  alt="Four rectangles drawn with different patterns." />

<p>We said earlier that we cannot draw before the image used by
a pattern is loaded. This can become rapidly complicated if we need to
draw using multiple patterns. We need a way to load all images and
then, <i>only when all images have been loaded, start drawing</i>.</p>

<p>JavaScript is an asynchronous language. When you set
the src attribute of an image, then an asynchronous request is sent by
the browser, and then after a while, the onload callback is called… The
difficult part to understand for those who are not familiar with
JavaScript is that these requests are done in parallel and we do not
know when, and in what order, the images will be loaded.</p>

<p>The solution is to use a multiple image loader that counts the loaded
images and calls a function you pass when done!</p>

<p>The trick is to have an array of URLs that will be used by our
multiple image loader, and have the onload callback called once per
image loaded, so we can count the number of images effectively
loaded.</p>

<p>When all images have been loaded, we call a callback function that
has been passed to our loader.</p>

<p>The complete example code that produces the result shown at the
beginning of this page is the following:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 181. multiple image loader (241) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image181.webp"
  loading="lazy"
  style="width:40%;"
  title="A multiple image loader"
  alt="A multiple image loader." />

<h4>HTML:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;A multiple image loader&lt;/title&gt;
  &lt;style&gt;
    #myCanvas {
      border: 1px solid black;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    // List of images to load, we used a JavaScript object instead of
    // an array, so that named indexes (aka properties)
    // can be used -&gt; easier to manipulate
    var imagesToLoad = {
      flowers: https://i.ibb.co/4NN9Sgn/flowers.jpg,
      lion: https://i.ibb.co/3NyqKnY/lion.jpg,
      blackAndWhiteLys: https://i.ibb.co/VNLVpcL/final.jpg,
      tiledFloor:
      https://i.ibb.co/Dt6txmG/repeatable-Pattern.jpg{
    };
    function loadImages(imagesToBeLoaded, drawCallback) {
      var imagesLoaded = {};
      var loadedImages = 0;
      var numberOfImagesToLoad = 0;
      // get num of sources
      for(var name in imagesToBeLoaded) {
        numberOfImagesToLoad++;
      }
      for(var name in imagesToBeLoaded) {
        imagesLoaded[name] = new Image();
        imagesLoaded[name].onload = function() {
          if(++loadedImages &gt;= numberOfImagesToLoad) {
            drawCallback(imagesLoaded);
          } // if
        }; // function
        imagesLoaded[name].src = imagesToBeLoaded[name];
      } // for
    } // function
    function init() {
      // This function is called after the page is loaded
      // 1 - Get the canvas
      canvas = document.getElementById(&#39;myCanvas&#39;);
      // 2 - Get the context
      ctx=canvas.getContext(&#39;2d&#39;);
      loadImages(imagesToLoad, function(imagesLoaded) {
        patternFlowers = ctx.createPattern(imagesLoaded.flowers, repeat);
        patternLion = ctx.createPattern(imagesLoaded.lion, repeat);
        patternBW = ctx.createPattern(imagesLoaded.blackAndWhiteLys, repeat);
       patternFloor = ctx.createPattern(imagesLoaded.tiledFloor, repeat);
        drawRectanglesWithPatterns();
      });
    }
    function drawRectanglesWithPatterns() {
      ctx.fillStyle=patternFloor;
      ctx.fillRect(0,0,200,200);
      ctx.fillStyle=patternLion;
      ctx.fillRect(200,0,200,200);
      ctx.fillStyle=patternFlowers;
      ctx.fillRect(0,200,200,200);
      ctx.fillStyle=patternBW;
      ctx.fillRect(200,200,200,200);
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;init();&quot;&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;
    Your browser does not support the canvas tag.
  &lt;/canvas&gt;
&lt;/body&gt;</pre>

</details>

<h4>Define the list of images to be loaded:</h4>

<pre>// List of images to load, we used a JavaScript object instead of
// an array, so that named indexes (aka properties)
// can be used -&gt; easier to read
var imagesToLoad = {
  flowers: https://i.ibb.co/4NN9Sgn/flowers.jpg,
  lion: https://i.ibb.co/3NyqKnY/lion.jpg,
  blackAndWhiteLys: https://i.ibb.co/VNLVpcL/final.jpg,
  tiledFloor:
  https://i.ibb.co/Dt6txmG/repeatable-Pattern.jpg
};</pre>

<p>Notice that instead of using a traditional array, we defined this list
as a JavaScript object, with properties whose names will be easier to
manipulate (flowers, lion, tiledFloor, etc.).</p>

<h4>The image loader function:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function loadImages(imagesToBeLoaded, drawCallback) {
  var imagesLoaded = {};
  var loadedImages = 0;
  var numberOfImagesToLoad = 0;
  // get num of images to load
  for(var name in imagesToBeLoaded) {
    numberOfImagesToLoad++;
  }
  for(var name in imagesToBeLoaded) {
    imagesLoaded[name] = new Image();
    imagesLoaded[name].onload = function() {
      if(++loadedImages &gt;= numberOfImagesToLoad) {
        drawCallback(imagesLoaded);
      } // if
    }; // function
    imagesLoaded[name].src = imagesToBeLoaded[name];
  } // for
} // function</pre>

</details>

<h4>Explanations:</h4>

<ul>
  <li>This function takes as a parameter the list of images to be loaded, and a drawCallback function that will be called only once all images have been loaded. This callback takes as a parameter a new object that is the list of images that have been loaded (see <i>line 16</i>).</li>
  <li>We first count the number of images to load (<i>lines 7-9</i>), then for each image to be loaded we create a new JavaScript image object (<i>line 12</i>) and set its src attribute (<i>line 19</i>) - this will start to load the image.</li>
  <li>When an image comes in, the onload callback is called (<i>line 14</i>) and inside, we increment the number of images loaded (<i>line 15</i>) and test if this number is &gt;=  the total number of images that should be loaded. If this is the case, the callback function is called (<i>line 16</i>).</li>
</ul>

<h4>Example of use of this loader</h4>

<pre>loadImages(imagesToLoad, function(imagesLoaded) {
  patternFlowers = ctx.createPattern(imagesLoaded.flowers, &#39;repeat&#39;);
  patternLion = ctx.createPattern(imagesLoaded.lion, &#39;repeat&#39;);
  patternBW = ctx.createPattern(imagesLoaded.blackAndWhiteLys, &#39;repeat&#39;);
  patternFloor = ctx.createPattern(imagesLoaded.tiledFloor, &#39;repeat&#39;);
  drawRectanglesWithPatterns();
});</pre>

<h4>Explanations:</h4>

<ul>
  <li><i>Line 1</i> is the call to the image loader, the first parameter is the list of images to be loaded, while the second parameter is the callback function that will be called once all images have been loaded.</li>
  <li><i>Lines 2-5</i>: in this callback we create patterns from the loaded images (note the use of the property names imagesLoaded.flowers, etc. that makes the code easier to read).</li>
  <li><i>Line 7</i>: then we call a function that will draw the rectangles.</li>
</ul>

<h4>Here is the function:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>function drawRectanglesWithPatterns() {
  ctx.fillStyle=patternFloor;
  ctx.fillRect(0,0,200,200);
  ctx.fillStyle=patternLion;
  ctx.fillRect(200,0,200,200);
  ctx.fillStyle=patternFlowers;
  ctx.fillRect(0,200,200,200);
  ctx.fillStyle=patternBW;
  ctx.fillRect(200,200,200,200);
}</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-6">3.5.6 Drawing Shadows</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h4>Context properties to draw with shadows</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 182. a green shadow rectangle (244) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image182.webp"
  loading="lazy"
  style="width:25%;"
  title="A green shadowed rectangle"
  alt="A green shadowed rectangle." />

<p>There are 4 properties of the canvas context that are useful for indicating that we want to draw shapes with shadows:</p>

<ol type="1">
  <li>shadowColor: color to use for shadows,</li>
  <li>shadowBlur: blur level for shadows,</li>
  <li>shadowOffsetX: horizontal distance of the shadow from the shape,</li>
  <li>shadowOffsetY: vertical distance of the shadow from the shape.</li>
</ol>

<h4>Examples</h4>

<h4>Example #1: simple shadows</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~ 183. example #1, simple shadows (245) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image183.webp"
  loading="lazy"
  style="width:40%;"
  title="Simple shadows, example #1"
  alt="Simple shadows, example #1." />

<h4>JavaScript:</h4>

<details>
  <summary><b>Click to expand!</b></summary>
  
<pre>var canvas, ctx;
function init() {
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  setShadow();
  // first green filled rectangle
  ctx.fillStyle = &quot;#22FFDD&quot;; // rectangle color
  ctx.fillRect(20, 20, 200, 100);
  // second stroked rectangle
  ctx.strokeStyle = &quot;purple&quot;; // rectangle color
  ctx.lineWidth=10;
  ctx.strokeRect(20, 150, 200, 100);
}
function setShadow() {
  ctx.shadowColor = &quot;Grey&quot;; // color
  ctx.shadowBlur = 20; // blur level
  ctx.shadowOffsetX = 15; // horizontal offset
  ctx.shadowOffsetY = 15; // vertical offset
}</pre>

</details>

<h4>HTML</h4>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Simple shadows - Example #1&lt;/title&gt;
&lt;/head&gt;
&lt;body onload = init();&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height =800&gt;
    Your browser does not support the canvas tag.&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<h4>JavaScript source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>var canvas, ctx;
function init() {
  canvas = document.getElementById(&#39;myCanvas&#39;);
  ctx = canvas.getContext(&#39;2d&#39;);
  // call to a function that will set the 4 context properties for shadows
  setShadow();
  // all drawings that will occur will cast shadows
  // first green filled rectangle
  ctx.fillStyle = &quot;#22FFDD&quot;; 
  ctx.fillRect(20, 20, 200, 100);
  // second stroked rectangle
  ctx.strokeStyle = &quot;purple&quot;; 
  ctx.lineWidth=10;
  ctx.strokeRect(20, 150, 200, 100);
}
// We define the 4 properties in a dedicated function, for clarity
function setShadow() {
  ctx.shadowColor = &quot;Grey&quot;;    // color
  ctx.shadowBlur = 20;         // blur level
  ctx.shadowOffsetX = 15;      // horizontal offset
  ctx.shadowOffsetY = 15;      // vertical offset
}</pre>

</details>

<h4>Explanations:</h4>

<ul>
  <li><i>Lines 21-27</i>: we set the 4 properties that define shadows in a dedicated 
    function, for better clarity.</li>
  <li><i>Line 8</i>: we called this function once before drawing the rectangles.</li>
  <li><i>Lines 11-18</i>: we draw a filled and a stroked rectangle. Both rectangles 
    cast shadows.</li>
</ul>

<h4>Example #2: unwanted shadows!</h4>

<p>Let’s take a <a href="https://codepen.io/w3devcampus/pen/YzZBxmO" target="_blank" 
rel="noopener noreferrer">previous example</a>, the one that draws a filled circle 
with an outline. And, let’s add a shadow to it using the following code:</p>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>...
ctx.beginPath();
// Add to the path a full circle (from 0 to 2PI)
ctx.arc(centerX, centerY, radius, 0, 2*Math.PI, false);
// With path drawing you can change the context
// properties until a call to stroke() or fill() is performed
ctx.fillStyle = &quot;lightBlue&quot;;
// add shadows before drawing the filled circle
addShadows();
// Draws the filled circle in light blue
ctx.fill();
// Prepare for the outline
ctx.lineWidth = 5;
ctx.strokeStyle = &quot;black&quot;;
// draws the path AGAIN (the circle), this
// time in wireframe
ctx.stroke();
// Notice we only once called context.arc()! And drew it twice
// with different styles
...
function addShadows() {
  ctx.shadowColor = &quot;Grey&quot;; // color
  ctx.shadowBlur = 20;      // blur level
  ctx.shadowOffsetX = 15;   // horizontal offset
  ctx.shadowOffsetY = 15;   // vertical offset
}</pre>

</details>

<h4>And here is the result:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~ 184. setting shadow - not quite correct (247) ~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image184.webp"
  loading="lazy"
  style="width:40%;"
  title="Not quite correct, unwanted shadow"
  alt="Not quite correct, unwanted shadow." />

<h4>HTML, CSS and JS:</h4>

<details>
  <summary><b>Click to expand!</b></summary>
  
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Unwanted shadows - Example #2&lt;/title&gt;
  &lt;style&gt;
    body {
      margin: 0px;
     padding: 0px;
    }
    #myCanvas {
      border: 1px solid #9C9898;
    }
  &lt;/style&gt;
&lt;script&gt;
  var canvas, ctx;
  window.onload = function(){
    canvas = document.getElementById(&quot;myCanvas&quot;);
    ctx = canvas.getContext(&quot;2d&quot;);
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    var radius = 70;
    ctx.beginPath();
    // Add to the path a full circle (from 0 to 2PI)
    ctx.arc(centerX, centerY, radius, 0, 2*Math.PI, false);
    // With path drawing you can change the context
    // properties until a call to stroke() or fill() is performed
    ctx.fillStyle = &quot;lightBlue&quot;;
    // add shadows before drawing the filled circle
    addShadows();
    // Draws the filled circle in light blue
    ctx.fill();
    // Prepare for the outline
    ctx.lineWidth = 5;
    ctx.strokeStyle = &quot;black&quot;;
    // draws AGAIN the path (the circle), this
    // time in wireframe
    ctx.stroke();
    // Notice we called context.arc() only once ! And drew it twice
    // with different styles
  };
  function addShadows() {
    ctx.shadowColor = &quot;Grey&quot;; // color
    ctx.shadowBlur = 20; // blur level
    ctx.shadowOffsetX = 15; // horizontal offset
    ctx.shadowOffsetY = 15; // vertical offset
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;578&quot; height=&quot;200&quot;&gt;
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>Ah, indeed, the call to ctx.fill() casts a shadow, but the call
to ctx.stroke(), that paints the whole path again, casts a shadow too,
and this time the outline produces an unwanted shadow… How can we avoid
this effect, while using the same technique for drawing the path?</p>
<p>The trick is to save the context before setting the shadow
properties, then draw the filled circle, then restore the context (to
its previous state: without shadows), then draw the outlined circle by
calling ctx.stroke().</p>

<h4>Correct version of the code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>...
// save the context before setting shadows and drawing the filled circle
ctx.save();
// With path drawing you can change the context
// properties until a call to stroke() or fill() is performed
ctx.fillStyle = &quot;lightBlue&quot;;
// add shadows before drawing the filled circle
addShadows();
// Draws the filled circle in light blue
ctx.fill();
// restore the context to its previous saved state
ctx.restore();
...</pre>

</details>

<h4>And here is the <em>FINAL</em> result:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 185. final result of setting shadow (248) ~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image185.webp"
  loading="lazy"
  style="width:40%;"
  title="Final result of setting shadow"
  alt="Final result of setting shadow." />

<h4>HTML, CSS and JS:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Unwanted shadows disappear- Example #2 bis&lt;/title&gt;
  &lt;style&gt;
     body {
   margin: 0px;
   padding: 0px;
    }
    #myCanvas {
    border: 1px solid #9C9898;
    }
  &lt;/style&gt;
  &lt;script&gt;
    var canvas, ctx;
    window.onload = function(){
    canvas = document.getElementById(&quot;myCanvas&quot;);
    ctx = canvas.getContext(&quot;2d&quot;);
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    var radius = 70;
    ctx.beginPath();
    // Add to the path a full circle (from 0 to 2PI)
    ctx.arc(centerX, centerY, radius, 0, 2*Math.PI, false);
    // save the context before setting shadows and drawing the filled circle
    ctx.save();
    // With path drawing you can change the context
    // properties until a call to stroke() or fill() is performed
    ctx.fillStyle = &quot;lightBlue&quot;;
    // add shadows before drawing the filled circle
    addShadows();
    // Draws the filled circle in light blue
    ctx.fill();
    // restore the context to its previous saved state
    ctx.restore();
    // Prepare for the outline
    ctx.lineWidth = 5;
    ctx.strokeStyle = &quot;black&quot;;
    // draws AGAIN the path (the circle), this
    // time in wireframe
    ctx.stroke();
    // Notice we called context.arc() only once ! And drew it twice
    // with different styles
    };
    function addShadows() {
    ctx.shadowColor = &quot;Grey&quot;; // color
    ctx.shadowBlur = 20; // blur level
    ctx.shadowOffsetX = 15; // horizontal offset
    ctx.shadowOffsetY = 15; // vertical offset
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;578&quot; height=&quot;200&quot;&gt;
  &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<h3 id="ch3-5-7">3.5.7 Styling Lines</h3>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<p>Several context properties can be used to set the thickness of the
shape outlines, the way line end caps are drawn, etc.</p>
<p>They apply to all shapes that are drawn in path mode (lines, curves,
arcs) and some also apply to rectangles.</p>

<h4>Examples of line styles</h4>

<h4>Example #1: changing the line thickness</h4>

<p>We have seen this before. This is done by changing the value (in
pixels) of the lineWidth property of the context:</p>

<pre>ctx.lineWidth = 10; // set the thickness of every shape drawn in stroke/wireframe mode to 10 pixels</pre>

<p>Here is a complete example where we draw with a lineWidth of 20 pixels:</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~ 186. changing the line thickness (250) ~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image186.webp"
  loading="lazy"
  style="width:40%;"
  title="Changing the line thickness"
  alt="Changing the line thickness." />

<h4>Source code:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;A simple example of lineWidth property use&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
    &lt;script&gt;
      var canvas = document.getElementById(&#39;myCanvas&#39;);
      var ctx = canvas.getContext(&#39;2d&#39;);
       // first path
      ctx.moveTo(20, 20);
      ctx.lineTo(100, 100);
      ctx.lineTo(100, 0);
      // second part of the path
      ctx.moveTo(120, 20);
      ctx.lineTo(200, 100);
      ctx.lineTo(200, 0);
      // indicate stroke color + draw first part of the path
      ctx.strokeStyle = &quot;#0000FF&quot;;
      // Current line thickness is 20 pixels
      ctx.lineWidth = 20;
      ctx.stroke();
      // Draws a rectangle
      ctx.strokeRect(230, 10, 100, 100);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Example #2: changing the end caps of a line</h4>

<p>The lineCap property of the context indicates the way line end caps are
rendered. Possible values are butt (default), round, square (from top to
bottom in the next illustration). Note that a value of “round” or
“square” makes the lines slightly longer than the default value “butt”.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 187. line cap values (251) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image187.webp"
  loading="lazy"
  title="Line cap values"
  alt="Line cap values."
  style="width:20%;" />

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~ 188. changing the end caps of a lines (251) ~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image188.webp"
  loading="lazy"
  title="Changing the end caps of a line.  Example #2"
  alt="Changing the end caps of a line.  Example #2."
  style="width:40%;" />

<h4>HTML, CSS and JS:</h4>

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Changing the end caps of a line - Example #2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot;&gt;Your browser does not support the canvas tag.&lt;/canvas&gt;
  &lt;script&gt;
    var canvas = document.getElementById(&#39;myCanvas&#39;);
    var ctx = canvas.getContext(&#39;2d&#39;);
    // first path
    ctx.moveTo(20, 20);
    ctx.lineTo(100, 100);
    ctx.lineTo(100, 30);
    // second part of the path
    ctx.moveTo(120, 20);
    ctx.lineTo(200, 100);
    ctx.lineTo(200, 30);
    // indicate stroke color + draw first part of the path
    ctx.strokeStyle = &quot;#0000FF&quot;;
    // Current line thickness is 20 pixels
    ctx.lineWidth = 20;
    // Try different values : butt, square, round
    ctx.lineCap = &quot;round&quot;;
    ctx.stroke();
    // Draws a rectangle
    ctx.strokeRect(230, 10, 100, 100);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<p>Note that in this example, the rectangle is not affected. It has no line ends visible - all its sides meet. However, the next property we’re going to look at will have an effect on rectangles!</p>

<h4>Example #3: setting the type of corner when two lines meet</h4>

<p>The lineJoin property of the context indicates the way corners are rendered, when two lines meet. Possible values are miter (the default) for creating sharp corners, round, or bevel for “cut corners”.</p>

<h4>Try this:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~ 189. setting type of corner when two lines meet (252) ~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image189.webp"
  loading="lazy"
  title="Setting type of corner when two lines meet"
  alt="Setting type of corner when two lines meet."
  style="width:40%;" />

<details>
  <summary><b>Click to expand!</b></summary>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Setting the type of corner when two lines meet - Example #3&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot;&gt;Your browser does not support the   canvas tag.&lt;/canvas&gt;
  &lt;script&gt;
    var canvas = document.getElementById(&#39;myCanvas&#39;);
    var ctx = canvas.getContext(&#39;2d&#39;);
    // first path
    ctx.moveTo(20,20);
    ctx.lineTo(100, 100);
    ctx.lineTo(100,30);
    // second part of the path
    ctx.moveTo(120,20);
    ctx.lineTo(200, 100);
    ctx.lineTo(200,30);
    // indicate stroke color + draw first part of the path
    ctx.strokeStyle = &quot;#0000FF&quot;;
    // Current line thickness is 20 pixels
    ctx.lineWidth = 20;
    // Try different values : miter(default), bevel, round
    ctx.lineJoin=&quot;round&quot;;
    ctx.stroke();
    // Draws a rectangle
    ctx.strokeRect(230, 10, 100, 100);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

</details>

<h4>Example #4: specific case of lineJoin=“miter”, the miterLimit property, a way to avoid looooooong corners!</h4>

<p>The miterLimit property value corresponds to the maximum miter length: the distance between the inner corner and the outer corner where two lines meet. When the angle of a corner between two lines gets smaller, the miter length grows and can become too long.</p>
<p>In order to avoid this situation, we can set the miterLimit property of the context to a threshold value. If the miter length exceeds the miterLimit value, then the corner will be rendered as if the lineJoin property had been set to “bevel” and the corner will be “cut”.</p>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~ 190. linejoin property - arrows fig 1, 2 and 3 (253) ~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image190.webp"
  loading="lazy"
  title="lineJoin property, figure 1, 2 and 3 showing arrows"
  alt="lineJoin property, figure 1, 2 and 3 showing arrows."
  style="width:20%;" />

<h4>You can try an interactive example here:</h4>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<!--~~~~~~~~~~~~~~~~~~~~~~~~ 191. miterlimit property explained (253) ~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<img class="displayed"
  src="./images/image191.webp"
  loading="lazy"
  title="Example #4: miterLimit property shown with 3 different angles, we see 
    that the part that goes out of the angle becomes very long"
  alt="Example #4: miterLimit property shown with 3 different angles, we see 
    that the part that goes out of the angle becomes very long."
  style="width:40%;" />

<p>In the example, try different values for the miterLimit property.  You’ll see that the way the corners are rendered changes at values around 2 and 3.</p>
